<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Series - Polars - Python Reference Guide</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../../favicon.png">
        
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        
        <link rel="stylesheet" href="../../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../../../theme/css/style.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../../../polars.html">polars</a></li><li class="chapter-item "><a href="../../../polars/datatypes.html">datatypes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/datatypes/DataType.html">DataType</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int8.html">Int8</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int16.html">Int16</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int32.html">Int32</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int64.html">Int64</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt8.html">UInt8</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt16.html">UInt16</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt32.html">UInt32</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt64.html">UInt64</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Float32.html">Float32</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Float64.html">Float64</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Boolean.html">Boolean</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Utf8.html">Utf8</a></li><li class="chapter-item "><a href="../../../polars/datatypes/List.html">List</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Date32.html">Date32</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Date64.html">Date64</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Time32Millisecond.html">Time32Millisecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Time32Second.html">Time32Second</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Time64Nanosecond.html">Time64Nanosecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Time64Microsecond.html">Time64Microsecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/DurationNanosecond.html">DurationNanosecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/DurationMicrosecond.html">DurationMicrosecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/DurationMillisecond.html">DurationMillisecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/DurationSecond.html">DurationSecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/TimestampNanosecond.html">TimestampNanosecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/TimestampMicrosecond.html">TimestampMicrosecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/TimestampMillisecond.html">TimestampMillisecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/TimestampSecond.html">TimestampSecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Object.html">Object</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Categorical.html">Categorical</a></li></ol></li><li class="chapter-item expanded "><a href="../../../polars/eager.html">eager</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/eager/frame.html">frame</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/eager/frame/DataFrame.html">DataFrame</a></li><li class="chapter-item "><a href="../../../polars/eager/frame/GroupBy.html">GroupBy</a></li><li class="chapter-item "><a href="../../../polars/eager/frame/PivotOps.html">PivotOps</a></li><li class="chapter-item "><a href="../../../polars/eager/frame/GBSelection.html">GBSelection</a></li></ol></li><li class="chapter-item expanded "><a href="../../../polars/eager/series.html">series</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../polars/eager/series/Series.html" class="active">Series</a></li><li class="chapter-item "><a href="../../../polars/eager/series/StringNameSpace.html">StringNameSpace</a></li><li class="chapter-item "><a href="../../../polars/eager/series/DateTimeNameSpace.html">DateTimeNameSpace</a></li><li class="chapter-item "><a href="../../../polars/eager/series/SeriesIter.html">SeriesIter</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../../polars/functions.html">functions</a></li><li class="chapter-item "><a href="../../../polars/io.html">io</a></li><li class="chapter-item "><a href="../../../polars/lazy.html">lazy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/lazy/expr.html">expr</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/lazy/expr/Expr.html">Expr</a></li><li class="chapter-item "><a href="../../../polars/lazy/expr/ExprStringNameSpace.html">ExprStringNameSpace</a></li><li class="chapter-item "><a href="../../../polars/lazy/expr/ExprDateTimeNameSpace.html">ExprDateTimeNameSpace</a></li></ol></li><li class="chapter-item "><a href="../../../polars/lazy/frame.html">frame</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/lazy/frame/LazyFrame.html">LazyFrame</a></li><li class="chapter-item "><a href="../../../polars/lazy/frame/LazyGroupBy.html">LazyGroupBy</a></li></ol></li><li class="chapter-item "><a href="../../../polars/lazy/functions.html">functions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/lazy/functions/UDF.html">UDF</a></li></ol></li><li class="chapter-item "><a href="../../../polars/lazy/whenthen.html">whenthen</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/lazy/whenthen/WhenThenThen.html">WhenThenThen</a></li><li class="chapter-item "><a href="../../../polars/lazy/whenthen/WhenThen.html">WhenThen</a></li><li class="chapter-item "><a href="../../../polars/lazy/whenthen/When.html">When</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../../polars/string_cache.html">string_cache</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/string_cache/StringCache.html">StringCache</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Polars - Python Reference Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="polarseagerseriesseries"><a class="header" href="#polarseagerseriesseries"><code>polars.eager.series.Series</code></a></h1>
<p>A Series represents a single column in a polars DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>name</code> [<code>str, default None</code>]: Name of the series. Will be used as a column name when used in a DataFrame.
When not specified, name is set to an empty string.</li>
<li><code>values</code> [<code>ArrayLike, default None</code>]: One-dimensional data in various forms. Supported are: Sequence, Series,
pyarrow Array, and numpy ndarray.</li>
<li><code>nullable</code> [<code>bool, default True</code>]: If set to True, Sequence values will be parsed with None interpreted as missing,
and numpy arrays will be parsed with NaN interpreted as missing. Note that
missing and NaN is not the same in Polars. If your data does not contain null
values, set to False to speed up Series creation.</li>
<li><code>dtype</code> [<code>DataType, default None</code>]: Polars dtype of the Series data. If not specified, the dtype is inferred.</li>
</ul>
<p><strong>Examples:</strong></p>
<p>Constructing a Series by specifying name and values positionally:</p>
<pre><code class="language-python">&gt;&gt;&gt; s = pl.Series('a', [1, 2, 3])
&gt;&gt;&gt; s
shape: (3,)
Series: 'a' [i64]
[
        1
        2
        3
]
</code></pre>
<p>Notice that the dtype is automatically inferred as a polars Int64:</p>
<pre><code class="language-python">&gt;&gt;&gt; s.dtype
&lt;class 'polars.datatypes.Int64'&gt;
</code></pre>
<p>Constructing a Series with a specific dtype:</p>
<pre><code class="language-python">&gt;&gt;&gt; s2 = pl.Series('a', [1, 2, 3], dtype=pl.Float32)
&gt;&gt;&gt; s2
shape: (3,)
Series: 'a' [f32]
[
        1
        2
        3
]
</code></pre>
<p>It is possible to construct a Series with values as the first positional argument.
This syntax considered an anti-pattern, but it can be useful in certain
scenarios. You must specify any other arguments through keywords.</p>
<pre><code class="language-python">&gt;&gt;&gt; s3 = pl.Series([1, 2, 3], nullable=False)
&gt;&gt;&gt; s3
shape: (3,)
Series: '' [i64]
[
        1
        2
        3
]
</code></pre>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="#polarseagerseriesseriesfrom_arrow"><code>from_arrow()</code></a></li>
<li><a href="#polarseagerseriesseriesinner"><code>inner()</code></a></li>
<li><a href="#polarseagerseriesseriesdrop_nulls"><code>drop_nulls()</code></a></li>
<li><a href="#polarseagerseriesseriesto_frame"><code>to_frame()</code></a></li>
<li><a href="#polarseagerseriesseriesdtype"><code>dtype()</code></a></li>
<li><a href="#polarseagerseriesseriesdescribe"><code>describe()</code></a></li>
<li><a href="#polarseagerseriesseriessum"><code>sum()</code></a></li>
<li><a href="#polarseagerseriesseriesmean"><code>mean()</code></a></li>
<li><a href="#polarseagerseriesseriesmin"><code>min()</code></a></li>
<li><a href="#polarseagerseriesseriesmax"><code>max()</code></a></li>
<li><a href="#polarseagerseriesseriesstd"><code>std()</code></a></li>
<li><a href="#polarseagerseriesseriesvar"><code>var()</code></a></li>
<li><a href="#polarseagerseriesseriesmedian"><code>median()</code></a></li>
<li><a href="#polarseagerseriesseriesquantile"><code>quantile()</code></a></li>
<li><a href="#polarseagerseriesseriesto_dummies"><code>to_dummies()</code></a></li>
<li><a href="#polarseagerseriesseriesvalue_counts"><code>value_counts()</code></a></li>
<li><a href="#polarseagerseriesseriesname"><code>name()</code></a></li>
<li><a href="#polarseagerseriesseriesrename"><code>rename()</code></a></li>
<li><a href="#polarseagerseriesserieschunk_lengths"><code>chunk_lengths()</code></a></li>
<li><a href="#polarseagerseriesseriesn_chunks"><code>n_chunks()</code></a></li>
<li><a href="#polarseagerseriesseriescum_sum"><code>cum_sum()</code></a></li>
<li><a href="#polarseagerseriesseriescum_min"><code>cum_min()</code></a></li>
<li><a href="#polarseagerseriesseriescum_max"><code>cum_max()</code></a></li>
<li><a href="#polarseagerseriesserieslimit"><code>limit()</code></a></li>
<li><a href="#polarseagerseriesseriesslice"><code>slice()</code></a></li>
<li><a href="#polarseagerseriesseriesappend"><code>append()</code></a></li>
<li><a href="#polarseagerseriesseriesfilter"><code>filter()</code></a></li>
<li><a href="#polarseagerseriesserieshead"><code>head()</code></a></li>
<li><a href="#polarseagerseriesseriestail"><code>tail()</code></a></li>
<li><a href="#polarseagerseriesseriestake_every"><code>take_every()</code></a></li>
<li><a href="#polarseagerseriesseriessort"><code>sort()</code></a></li>
<li><a href="#polarseagerseriesseriesargsort"><code>argsort()</code></a></li>
<li><a href="#polarseagerseriesseriesarg_sort"><code>arg_sort()</code></a></li>
<li><a href="#polarseagerseriesseriesarg_unique"><code>arg_unique()</code></a></li>
<li><a href="#polarseagerseriesseriesarg_min"><code>arg_min()</code></a></li>
<li><a href="#polarseagerseriesseriesarg_max"><code>arg_max()</code></a></li>
<li><a href="#polarseagerseriesseriesunique"><code>unique()</code></a></li>
<li><a href="#polarseagerseriesseriestake"><code>take()</code></a></li>
<li><a href="#polarseagerseriesseriesnull_count"><code>null_count()</code></a></li>
<li><a href="#polarseagerseriesseriesis_null"><code>is_null()</code></a></li>
<li><a href="#polarseagerseriesseriesis_not_null"><code>is_not_null()</code></a></li>
<li><a href="#polarseagerseriesseriesis_finite"><code>is_finite()</code></a></li>
<li><a href="#polarseagerseriesseriesis_infinite"><code>is_infinite()</code></a></li>
<li><a href="#polarseagerseriesseriesis_nan"><code>is_nan()</code></a></li>
<li><a href="#polarseagerseriesseriesis_not_nan"><code>is_not_nan()</code></a></li>
<li><a href="#polarseagerseriesseriesis_in"><code>is_in()</code></a></li>
<li><a href="#polarseagerseriesseriesarg_true"><code>arg_true()</code></a></li>
<li><a href="#polarseagerseriesseriesis_unique"><code>is_unique()</code></a></li>
<li><a href="#polarseagerseriesseriesis_first"><code>is_first()</code></a></li>
<li><a href="#polarseagerseriesseriesis_duplicated"><code>is_duplicated()</code></a></li>
<li><a href="#polarseagerseriesseriesexplode"><code>explode()</code></a></li>
<li><a href="#polarseagerseriesseriesseries_equal"><code>series_equal()</code></a></li>
<li><a href="#polarseagerseriesserieslen"><code>len()</code></a></li>
<li><a href="#polarseagerseriesseriesshape"><code>shape()</code></a></li>
<li><a href="#polarseagerseriesseriescast"><code>cast()</code></a></li>
<li><a href="#polarseagerseriesseriesto_list"><code>to_list()</code></a></li>
<li><a href="#polarseagerseriesseriesrechunk"><code>rechunk()</code></a></li>
<li><a href="#polarseagerseriesseriesis_numeric"><code>is_numeric()</code></a></li>
<li><a href="#polarseagerseriesseriesis_float"><code>is_float()</code></a></li>
<li><a href="#polarseagerseriesseriesis_boolean"><code>is_boolean()</code></a></li>
<li><a href="#polarseagerseriesseriesis_utf8"><code>is_utf8()</code></a></li>
<li><a href="#polarseagerseriesseriesview"><code>view()</code></a></li>
<li><a href="#polarseagerseriesseriesto_numpy"><code>to_numpy()</code></a></li>
<li><a href="#polarseagerseriesseriesto_arrow"><code>to_arrow()</code></a></li>
<li><a href="#polarseagerseriesseriesset"><code>set()</code></a></li>
<li><a href="#polarseagerseriesseriesset_at_idx"><code>set_at_idx()</code></a></li>
<li><a href="#polarseagerseriesseriesclone"><code>clone()</code></a></li>
<li><a href="#polarseagerseriesseriesfill_none"><code>fill_none()</code></a></li>
<li><a href="#polarseagerseriesseriesround"><code>round()</code></a></li>
<li><a href="#polarseagerseriesseriesdot"><code>dot()</code></a></li>
<li><a href="#polarseagerseriesseriesapply"><code>apply()</code></a></li>
<li><a href="#polarseagerseriesseriesshift"><code>shift()</code></a></li>
<li><a href="#polarseagerseriesserieszip_with"><code>zip_with()</code></a></li>
<li><a href="#polarseagerseriesseriesas_duration"><code>as_duration()</code></a></li>
<li><a href="#polarseagerseriesseriesrolling_min"><code>rolling_min()</code></a></li>
<li><a href="#polarseagerseriesseriesrolling_max"><code>rolling_max()</code></a></li>
<li><a href="#polarseagerseriesseriesrolling_mean"><code>rolling_mean()</code></a></li>
<li><a href="#polarseagerseriesseriesrolling_sum"><code>rolling_sum()</code></a></li>
<li><a href="#polarseagerseriesseriesparse_date"><code>parse_date()</code></a></li>
<li><a href="#polarseagerseriesseriessample"><code>sample()</code></a></li>
<li><a href="#polarseagerseriesseriespeak_max"><code>peak_max()</code></a></li>
<li><a href="#polarseagerseriesseriespeak_min"><code>peak_min()</code></a></li>
<li><a href="#polarseagerseriesseriesn_unique"><code>n_unique()</code></a></li>
<li><a href="#polarseagerseriesseriesshrink_to_fit"><code>shrink_to_fit()</code></a></li>
<li><a href="#polarseagerseriesseriesdt"><code>dt()</code></a></li>
<li><a href="#polarseagerseriesseriesstr"><code>str()</code></a></li>
<li><a href="#polarseagerseriesserieshash"><code>hash()</code></a></li>
<li><a href="#polarseagerseriesseriesreinterpret"><code>reinterpret()</code></a></li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Series:
    &quot;&quot;&quot;
    A Series represents a single column in a polars DataFrame.

    Parameters
    ----------
    name : str, default None
        Name of the series. Will be used as a column name when used in a DataFrame.
        When not specified, name is set to an empty string.
    values : ArrayLike, default None
        One-dimensional data in various forms. Supported are: Sequence, Series,
        pyarrow Array, and numpy ndarray.
    nullable : bool, default True
        If set to True, Sequence values will be parsed with None interpreted as missing,
        and numpy arrays will be parsed with NaN interpreted as missing. Note that
        missing and NaN is not the same in Polars. If your data does not contain null
        values, set to False to speed up Series creation.
    dtype : DataType, default None
        Polars dtype of the Series data. If not specified, the dtype is inferred.

    Examples
    --------
    Constructing a Series by specifying name and values positionally:

    ```python
    &gt;&gt;&gt; s = pl.Series('a', [1, 2, 3])
    &gt;&gt;&gt; s
    shape: (3,)
    Series: 'a' [i64]
    [
            1
            2
            3
    ]
    ```

    Notice that the dtype is automatically inferred as a polars Int64:

    ```python
    &gt;&gt;&gt; s.dtype
    &lt;class 'polars.datatypes.Int64'&gt;
    ```

    Constructing a Series with a specific dtype:

    ```python
    &gt;&gt;&gt; s2 = pl.Series('a', [1, 2, 3], dtype=pl.Float32)
    &gt;&gt;&gt; s2
    shape: (3,)
    Series: 'a' [f32]
    [
            1
            2
            3
    ]
    ```

    It is possible to construct a Series with values as the first positional argument.
    This syntax considered an anti-pattern, but it can be useful in certain
    scenarios. You must specify any other arguments through keywords.

    ```python
    &gt;&gt;&gt; s3 = pl.Series([1, 2, 3], nullable=False)
    &gt;&gt;&gt; s3
    shape: (3,)
    Series: '' [i64]
    [
            1
            2
            3
    ]
    ```
    &quot;&quot;&quot;

    def __init__(
        self,
        name: Optional[Union[str, ArrayLike]] = None,
        values: Optional[ArrayLike] = None,
        nullable: bool = True,
        dtype: Optional[Type[DataType]] = None,
    ):
        # Handle case where values are passed as the first argument
        if name is not None and not isinstance(name, str):
            if values is None:
                values = name
                name = None
            else:
                raise ValueError(&quot;Series name must be a string.&quot;)

        # TODO: Remove if-statement below once Series name is allowed to be None
        if name is None:
            name = &quot;&quot;

        self._s: PySeries

        # series path
        if isinstance(values, Series):
            values.rename(name, in_place=True)
            self._s = values._s
            return
        elif isinstance(values, pa.Array):
            self._s = self.from_arrow(name, values)._s
            return
        elif isinstance(values, dict):
            raise ValueError(
                f&quot;Constructing a Series with a dict is not supported for {values}&quot;
            )

        # Handle empty values in constructor
        if values is None:
            values = []
        if dtype is None and isinstance(values, Sequence) and len(values) == 0:
            dtype = Float32

        # castable to numpy
        if not isinstance(values, np.ndarray) and not nullable:
            values = np.array(values)

        # numpy path
        if isinstance(values, np.ndarray):
            if not values.data.contiguous:
                values = np.array(values)
            if len(values.shape) &gt; 1:
                self._s = PySeries.new_object(name, values)
                return
            dtype = values.dtype
            if dtype == np.int64:
                self._s = PySeries.new_i64(name, values)
            elif dtype == np.int32:
                self._s = PySeries.new_i32(name, values)
            elif dtype == np.int16:
                self._s = PySeries.new_i16(name, values)
            elif dtype == np.int8:
                self._s = PySeries.new_i8(name, values)
            elif dtype == np.float32:
                self._s = PySeries.new_f32(name, values, nullable)
            elif dtype == np.float64:
                self._s = PySeries.new_f64(name, values, nullable)
            elif isinstance(values[0], str):
                self._s = PySeries.new_str(name, values)
            elif dtype == bool:
                self._s = PySeries.new_bool(name, values)
            elif dtype == np.uint8:
                self._s = PySeries.new_u8(name, values)
            elif dtype == np.uint16:
                self._s = PySeries.new_u16(name, values)
            elif dtype == np.uint32:
                self._s = PySeries.new_u32(name, values)
            elif dtype == np.uint64:
                self._s = PySeries.new_u64(name, values)
            else:
                self._s = PySeries.new_object(name, values)
            return
        # sequence path
        else:
            if dtype is not None:
                if dtype == Date32:
                    self._s = PySeries.new_opt_i32(name, values)
                    self._s = self.cast(Date32)._s
                elif dtype == Date64:
                    self._s = PySeries.new_opt_i32(name, values)
                    self._s = self.cast(Date64)._s
                elif dtype == Int32:
                    self._s = PySeries.new_opt_i32(name, values)
                elif dtype == Int64:
                    self._s = PySeries.new_opt_i64(name, values)
                elif dtype == Float32:
                    self._s = PySeries.new_opt_f32(name, values)
                elif dtype == Float64:
                    self._s = PySeries.new_opt_f64(name, values)
                elif dtype == Boolean:
                    self._s = PySeries.new_opt_bool(name, values)
                elif dtype == Utf8:
                    self._s = PySeries.new_str(name, values)
                elif dtype == Int16:
                    self._s = PySeries.new_opt_i16(name, values)
                elif dtype == Int8:
                    self._s = PySeries.new_opt_i8(name, values)
                elif dtype == UInt8:
                    self._s = PySeries.new_opt_u8(name, values)
                elif dtype == UInt16:
                    self._s = PySeries.new_opt_u16(name, values)
                elif dtype == UInt32:
                    self._s = PySeries.new_opt_u32(name, values)
                elif dtype == UInt64:
                    self._s = PySeries.new_opt_u64(name, values)
                elif dtype == Object:
                    self._s = PySeries.new_object(name, values)
                else:
                    raise ValueError(f&quot;{dtype} not yet implemented&quot;)
            else:
                dtype = _find_first_non_none(values)
                # order is important as booleans are instance of int in python.
                if isinstance(dtype, bool):
                    self._s = PySeries.new_opt_bool(name, values)
                elif isinstance(dtype, int):
                    self._s = PySeries.new_opt_i64(name, values)
                elif isinstance(dtype, float):
                    self._s = PySeries.new_opt_f64(name, values)
                elif isinstance(dtype, str):
                    self._s = PySeries.new_str(name, values)
                elif isinstance(dtype, datetime):
                    arrow_array = pa.array(values)
                    s = pl.from_arrow(arrow_array)
                    self._s = s._s
                    self._s.rename(name)
                elif isinstance(dtype, date):
                    arrow_array = pa.array(values)
                    s = pl.from_arrow(arrow_array)
                    self._s = s._s
                    self._s.rename(name)
                # make list array
                elif isinstance(dtype, (list, tuple)):
                    value_dtype = _find_first_non_none(dtype)

                    # we can expect a failure if we pass `[[12], &quot;foo&quot;, 9]`
                    # in that case we catch the exception and create an object type
                    try:
                        if isinstance(value_dtype, bool):
                            arrow_array = pa.array(values, pa.large_list(pa.bool_()))
                        elif isinstance(value_dtype, int):
                            arrow_array = pa.array(values, pa.large_list(pa.int64()))
                        elif isinstance(value_dtype, float):
                            arrow_array = pa.array(values, pa.large_list(pa.float64()))
                        elif isinstance(value_dtype, str):
                            arrow_array = pa.array(
                                values, pa.large_list(pa.large_utf8())
                            )
                        else:
                            self._s = PySeries.new_object(name, values)
                            return
                        self._s = Series.from_arrow(name, arrow_array)._s

                    except pa.lib.ArrowInvalid:
                        self._s = PySeries.new_object(name, values)
                else:
                    self._s = PySeries.new_object(name, values)

    @staticmethod
    def _from_pyseries(s: &quot;PySeries&quot;) -&gt; &quot;Series&quot;:
        self = Series.__new__(Series)
        self._s = s
        return self

    @staticmethod
    def _repeat(name: str, val: str, n: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Only used for strings.
        &quot;&quot;&quot;
        return Series._from_pyseries(PySeries.repeat(name, val, n))

    @staticmethod
    def from_arrow(name: str, array: pa.Array) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Create a Series from an arrow array.

        Parameters
        ----------
        name
            name of the Series.
        array
            Arrow array.
        &quot;&quot;&quot;
        array = coerce_arrow(array)
        return Series._from_pyseries(PySeries.from_arrow(name, array))

    def inner(self) -&gt; &quot;PySeries&quot;:
        return self._s

    def __str__(self) -&gt; str:
        return self._s.as_str()

    def __repr__(self) -&gt; str:
        return self.__str__()

    def __and__(self, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        return wrap_s(self._s.bitand(other._s))

    def __or__(self, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        return wrap_s(self._s.bitor(other._s))

    def __eq__(self, other: Any) -&gt; &quot;Series&quot;:  # type: ignore[override]
        if isinstance(other, Sequence) and not isinstance(other, str):
            other = Series(&quot;&quot;, other, nullable=True)
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.eq(other._s))
        f = get_ffi_func(&quot;eq_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __ne__(self, other: Any) -&gt; &quot;Series&quot;:  # type: ignore[override]
        if isinstance(other, Sequence) and not isinstance(other, str):
            other = Series(&quot;&quot;, other, nullable=True)
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.neq(other._s))
        f = get_ffi_func(&quot;neq_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __gt__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Sequence) and not isinstance(other, str):
            other = Series(&quot;&quot;, other, nullable=True)
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.gt(other._s))
        f = get_ffi_func(&quot;gt_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __lt__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Sequence) and not isinstance(other, str):
            other = Series(&quot;&quot;, other, nullable=True)
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.lt(other._s))
        f = get_ffi_func(&quot;lt_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __ge__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Sequence) and not isinstance(other, str):
            other = Series(&quot;&quot;, other, nullable=True)
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.gt_eq(other._s))
        f = get_ffi_func(&quot;gt_eq_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __le__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Sequence) and not isinstance(other, str):
            other = Series(&quot;&quot;, other, nullable=True)
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.lt_eq(other._s))
        f = get_ffi_func(&quot;lt_eq_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __add__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, str):
            other = Series(&quot;&quot;, [other])
        if isinstance(other, Series):
            return wrap_s(self._s.add(other._s))
        dtype = dtype_to_primitive(self.dtype)
        f = get_ffi_func(&quot;add_&lt;&gt;&quot;, dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __sub__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.sub(other._s))
        dtype = dtype_to_primitive(self.dtype)
        f = get_ffi_func(&quot;sub_&lt;&gt;&quot;, dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __truediv__(self, other: Any) -&gt; &quot;Series&quot;:
        primitive = dtype_to_primitive(self.dtype)
        if self.dtype != primitive:
            return self.__floordiv__(other)

        if self.is_float():
            out_dtype = self.dtype
        else:
            out_dtype = Float64
        return np.true_divide(self, other, dtype=out_dtype)  # type: ignore[call-overload]

    def __floordiv__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.div(other._s))
        dtype = dtype_to_primitive(self.dtype)
        f = get_ffi_func(&quot;div_&lt;&gt;&quot;, dtype, self._s)
        return wrap_s(f(other))

    def __mul__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.mul(other._s))
        dtype = dtype_to_primitive(self.dtype)
        f = get_ffi_func(&quot;mul_&lt;&gt;&quot;, dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __radd__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.add(other._s))
        dtype = dtype_to_primitive(self.dtype)
        f = get_ffi_func(&quot;add_&lt;&gt;_rhs&quot;, dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __rsub__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(other._s.sub(self._s))
        dtype = dtype_to_primitive(self.dtype)
        f = get_ffi_func(&quot;sub_&lt;&gt;_rhs&quot;, dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __invert__(self) -&gt; &quot;Series&quot;:
        if self.dtype == Boolean:
            return wrap_s(self._s._not())
        return NotImplemented

    def __rtruediv__(self, other: Any) -&gt; np.ndarray:

        primitive = dtype_to_primitive(self.dtype)
        if self.dtype != primitive:
            self.__rfloordiv__(other)

        if self.is_float():
            out_dtype = self.dtype
        else:
            out_dtype = Float64
        return np.true_divide(other, self, dtype=out_dtype)  # type: ignore[call-overload]

    def __rfloordiv__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(other._s.div(self._s))
        dtype = dtype_to_primitive(self.dtype)
        f = get_ffi_func(&quot;div_&lt;&gt;_rhs&quot;, dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __rmul__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.mul(other._s))
        dtype = dtype_to_primitive(self.dtype)
        f = get_ffi_func(&quot;mul_&lt;&gt;&quot;, dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __getitem__(self, item: Any) -&gt; Any:
        if isinstance(item, int):
            if item &gt;= self.len():
                raise IndexError
        # assume it is boolean mask
        if isinstance(item, Series):
            return Series._from_pyseries(self._s.filter(item._s))
        # slice
        if type(item) == slice:
            start, stop, stride = item.indices(self.len())
            out = self.slice(start, stop - start)
            if stride != 1:
                return out.take_every(stride)
            else:
                return out
        f = get_ffi_func(&quot;get_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        out = f(item)
        if self.dtype == List:
            return wrap_s(out)
        return out

    def __setitem__(self, key: Any, value: Any) -&gt; None:
        if isinstance(key, Series):
            if key.dtype == Boolean:
                self._s = self.set(key, value)._s
            elif key.dtype == UInt64:
                self._s = self.set_at_idx(key, value)._s
            elif key.dtype == UInt32:
                self._s = self.set_at_idx(key.cast(UInt64), value)._s
        # TODO: implement for these types without casting to series
        elif isinstance(key, (np.ndarray, list, tuple)):
            s = wrap_s(PySeries.new_u64(&quot;&quot;, np.array(key, np.uint64)))
            self.__setitem__(s, value)
        elif isinstance(key, int):
            self.__setitem__([key], value)
        else:
            raise ValueError(f'cannot use &quot;{key}&quot; for indexing')

    def drop_nulls(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Create a new Series that copies data from this Series without null values.
        &quot;&quot;&quot;
        return wrap_s(self._s.drop_nulls())

    def to_frame(self) -&gt; &quot;pl.DataFrame&quot;:
        &quot;&quot;&quot;
        Cast this Series to a DataFrame.
        &quot;&quot;&quot;
        return pl.eager.frame.wrap_df(PyDataFrame([self._s]))

    @property
    def dtype(self) -&gt; Type[DataType]:
        &quot;&quot;&quot;
        Get the data type of this Series.
        &quot;&quot;&quot;
        return DTYPES[self._s.dtype()]

    def describe(self) -&gt; Dict[str, Union[int, float]]:
        &quot;&quot;&quot;
        Quick summary statistics of a series. Series with mixed datatypes will return summary statistics for the datatype of the first value.

        Returns
        ---
        Dictionary with summary statistics of a series.

        Example
        ---
        ```python
        &gt;&gt;&gt; series_num = pl.Series([1, 2, 3, 4, 5])
        &gt;&gt;&gt; series_num.describe()
        {'min': 1, 'max': 5, 'sum': 15, 'mean': 3.0, 'std': 1.4142135623730951, 'count': 5}

        &gt;&gt;&gt; series_str = pl.Series([&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
        &gt;&gt;&gt; series_str.describe()
        {'unique': 3, 'count': 4}
        ```
        &quot;&quot;&quot;
        if len(self) == 0:
            raise ValueError(&quot;Series must contain at least one value&quot;)
        elif self.is_numeric():
            return {
                &quot;min&quot;: self.min(),
                &quot;max&quot;: self.max(),
                &quot;sum&quot;: self.sum(),
                &quot;mean&quot;: self.mean(),
                &quot;std&quot;: self.std(),
                &quot;count&quot;: len(self),
            }
        elif self.is_boolean():
            return {&quot;sum&quot;: self.sum(), &quot;count&quot;: len(self)}
        elif self.is_utf8():
            return {&quot;unique&quot;: len(self.unique()), &quot;count&quot;: len(self)}
        else:
            raise TypeError(&quot;This type is not supported&quot;)

    def sum(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Reduce this Series to the sum value.
        &quot;&quot;&quot;
        return self._s.sum()

    def mean(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Reduce this Series to the mean value.
        &quot;&quot;&quot;
        return self._s.mean()

    def min(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Get the minimal value in this Series.
        &quot;&quot;&quot;
        return self._s.min()

    def max(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Get the maximum value in this Series.
        &quot;&quot;&quot;
        return self._s.max()

    def std(self, ddof: int = 1) -&gt; float:
        &quot;&quot;&quot;
        Get the standard deviation of this Series.

        Parameters
        ----------
        ddof
            “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof,
            where N represents the number of elements.
            By default ddof is 1.
        &quot;&quot;&quot;
        return np.std(self.drop_nulls().view(), ddof=ddof)

    def var(self, ddof: int = 1) -&gt; float:
        &quot;&quot;&quot;
        Get variance of this Series.

        Parameters
        ----------
        ddof
            “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof,
            where N represents the number of elements.
            By default ddof is 1.
        &quot;&quot;&quot;
        return np.var(self.drop_nulls().view(), ddof=ddof)

    def median(self) -&gt; float:
        &quot;&quot;&quot;
        Get the median of this Series.
        &quot;&quot;&quot;
        return self._s.median()

    def quantile(self, quantile: float) -&gt; float:
        &quot;&quot;&quot;
        Get the quantile value of this Series.
        &quot;&quot;&quot;
        return self._s.quantile(quantile)

    def to_dummies(self) -&gt; &quot;pl.DataFrame&quot;:
        &quot;&quot;&quot;
        Get dummy variables.
        &quot;&quot;&quot;
        return pl.eager.frame.wrap_df(self._s.to_dummies())

    def value_counts(self) -&gt; &quot;pl.DataFrame&quot;:
        &quot;&quot;&quot;
        Count the unique values in a Series.
        &quot;&quot;&quot;
        return pl.eager.frame.wrap_df(self._s.value_counts())

    @property
    def name(self) -&gt; str:
        &quot;&quot;&quot;
        Get the name of this Series.
        &quot;&quot;&quot;
        return self._s.name()

    def rename(self, name: str, in_place: bool = False) -&gt; Optional[&quot;Series&quot;]:
        &quot;&quot;&quot;
        Rename this Series.

        Parameters
        ----------
        name
            New name.
        in_place
            Modify the Series in-place.
        &quot;&quot;&quot;
        if in_place:
            self._s.rename(name)
            return None
        else:
            s = self.clone()
            s._s.rename(name)
            return s

    def chunk_lengths(self) -&gt; tp.List[int]:
        &quot;&quot;&quot;
        Get the length of each individual chunk.
        &quot;&quot;&quot;
        return self._s.chunk_lengths()

    def n_chunks(self) -&gt; int:
        &quot;&quot;&quot;
        Get the number of chunks that this Series contains.
        &quot;&quot;&quot;
        return self._s.n_chunks()

    def cum_sum(self, reverse: bool = False) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Get an array with the cumulative sum computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.
        &quot;&quot;&quot;
        return self._s.cum_sum(reverse)

    def cum_min(self, reverse: bool = False) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Get an array with the cumulative min computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.
        &quot;&quot;&quot;
        return self._s.cum_min(reverse)

    def cum_max(self, reverse: bool = False) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Get an array with the cumulative max computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.
        &quot;&quot;&quot;
        return self._s.cum_max(reverse)

    def limit(self, num_elements: int = 10) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take n elements from this Series.

        Parameters
        ----------
        num_elements
            Amount of elements to take.
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.limit(num_elements))

    def slice(self, offset: int, length: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a slice of this Series.

        Parameters
        ----------
        offset
            Offset index.
        length
            Length of the slice.
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.slice(offset, length))

    def append(self, other: &quot;Series&quot;) -&gt; None:
        &quot;&quot;&quot;
        Append a Series to this one.

        Parameters
        ----------
        other
            Series to append.
        &quot;&quot;&quot;
        self._s.append(other._s)

    def filter(self, predicate: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Filter elements by a boolean mask.

        Parameters
        ----------
        predicate
            Boolean mask.
        &quot;&quot;&quot;
        if isinstance(predicate, list):
            predicate = Series(&quot;&quot;, predicate)
        return Series._from_pyseries(self._s.filter(predicate._s))

    def head(self, length: Optional[int] = None) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get first N elements as Series.

        Parameters
        ----------
        length
            Length of the head.
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.head(length))

    def tail(self, length: Optional[int] = None) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get last N elements as Series.

        Parameters
        ----------
        length
            Length of the tail.
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.tail(length))

    def take_every(self, n: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take every nth value in the Series and return as new Series.
        &quot;&quot;&quot;
        return wrap_s(self._s.take_every(n))

    def sort(self, in_place: bool = False, reverse: bool = False) -&gt; Optional[&quot;Series&quot;]:
        &quot;&quot;&quot;
        Sort this Series.

        Parameters
        ----------
        in_place
            Sort in place.
        reverse
            Reverse sort.
        &quot;&quot;&quot;
        if in_place:
            self._s.sort_in_place(reverse)
            return None
        else:
            return wrap_s(self._s.sort(reverse))

    def argsort(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        ..deprecate::

        Index location of the sorted variant of this Series.

        Returns
        -------
        indexes
            Indexes that can be used to sort this array.
        &quot;&quot;&quot;
        return wrap_s(self._s.argsort(reverse))

    def arg_sort(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Index location of the sorted variant of this Series.

        Returns
        -------
        indexes
            Indexes that can be used to sort this array.
        &quot;&quot;&quot;
        return wrap_s(self._s.argsort(reverse))

    def arg_unique(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get unique index as Series.
        &quot;&quot;&quot;
        return self._s.arg_unique()

    def arg_min(self) -&gt; Optional[int]:
        &quot;&quot;&quot;
        Get the index of the minimal value.
        &quot;&quot;&quot;
        return self._s.arg_min()

    def arg_max(self) -&gt; Optional[int]:
        &quot;&quot;&quot;
        Get the index of the maxima value.
        &quot;&quot;&quot;
        return self._s.arg_max()

    def unique(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get unique elements in series.
        &quot;&quot;&quot;
        return wrap_s(self._s.unique())

    def take(self, indices: Union[np.ndarray, tp.List[int]]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take values by index.

        Parameters
        ----------
        indices
            Index location used for selection.
        &quot;&quot;&quot;
        if isinstance(indices, list):
            indices = np.array(indices)
        return Series._from_pyseries(self._s.take(indices))

    def null_count(self) -&gt; int:
        &quot;&quot;&quot;
        Count the null values in this Series.
        &quot;&quot;&quot;
        return self._s.null_count()

    def is_null(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of null values.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_null())

    def is_not_null(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of non null values.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_not_null())

    def is_finite(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of finite values if Series dtype is Float.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_finite())

    def is_infinite(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of infinite values if Series dtype is Float.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_infinite())

    def is_nan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of NaN values if Series dtype is Float.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_nan())

    def is_not_nan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get negated mask of NaN values if Series dtype is_not Float.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_not_nan())

    def is_in(self, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Check if elements of this Series are in the right Series, or List values of the right Series.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        if type(other) is list:
            other = Series(&quot;&quot;, other)
        return wrap_s(self._s.is_in(other._s))

    def arg_true(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get index values where Boolean Series evaluate True.

        Returns
        -------
        UInt32 Series
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.arg_true())

    def is_unique(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of all unique values.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return wrap_s(self._s.is_unique())

    def is_first(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a mask of the first unique value.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return wrap_s(self._s.is_first())

    def is_duplicated(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of all duplicated values.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return wrap_s(self._s.is_duplicated())

    def explode(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Explode a list or utf8 Series. This means that every item is expanded to a new row.

        Returns
        -------
        Exploded Series of same dtype
        &quot;&quot;&quot;
        return wrap_s(self._s.explode())

    def series_equal(self, other: &quot;Series&quot;, null_equal: bool = False) -&gt; bool:
        &quot;&quot;&quot;
        Check if series is equal with another Series.

        Parameters
        ----------
        other
            Series to compare with.
        null_equal
            Consider null values as equal.
        &quot;&quot;&quot;
        return self._s.series_equal(other._s, null_equal)

    def len(self) -&gt; int:
        &quot;&quot;&quot;
        Length of this Series.
        &quot;&quot;&quot;
        return self._s.len()

    @property
    def shape(self) -&gt; Tuple[int]:
        &quot;&quot;&quot;
        Shape of this Series.
        &quot;&quot;&quot;
        return (self._s.len(),)

    def __len__(self) -&gt; int:
        return self.len()

    def cast(self, data_type: Type[DataType]) -&gt; &quot;Series&quot;:
        if data_type == int:
            data_type = Int64
        elif data_type == str:
            data_type = Utf8
        elif data_type == float:
            data_type = Float64
        f = get_ffi_func(&quot;cast_&lt;&gt;&quot;, data_type, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f())

    def to_list(self) -&gt; tp.List[Optional[Any]]:
        &quot;&quot;&quot;
        Convert this Series to a Python List. This operation clones data.
        &quot;&quot;&quot;
        if self.dtype != Object:
            return self.to_arrow().to_pylist()
        return self._s.to_list()

    def __iter__(self) -&gt; &quot;SeriesIter&quot;:
        return SeriesIter(self.len(), self)

    def rechunk(self, in_place: bool = False) -&gt; Optional[&quot;Series&quot;]:
        &quot;&quot;&quot;
        Create a single chunk of memory for this Series.

        Parameters
        ----------
        in_place
            In place or not.
        &quot;&quot;&quot;
        opt_s = self._s.rechunk(in_place)
        if in_place:
            return None
        else:
            return wrap_s(opt_s)

    def is_numeric(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series datatype is numeric.
        &quot;&quot;&quot;
        return self.dtype in (
            Int8,
            Int16,
            Int32,
            Int64,
            UInt8,
            UInt16,
            UInt32,
            UInt64,
            Float32,
            Float64,
        )

    def is_float(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series has floating point numbers.
        &quot;&quot;&quot;
        return self.dtype in (Float32, Float64)

    def is_boolean(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series is a Boolean.
        &quot;&quot;&quot;
        return self.dtype is Boolean

    def is_utf8(self) -&gt; bool:
        &quot;&quot;&quot;
        Checks if this Series datatype is a Utf8.
        &quot;&quot;&quot;
        return self.dtype is Utf8

    def view(self, ignore_nulls: bool = False) -&gt; np.ndarray:
        &quot;&quot;&quot;
        Get a view into this Series data with a numpy array. This operation doesn't clone data, but does not include
        missing values. Don't use this unless you know what you are doing.

        # Safety.

        This function can lead to undefined behavior in the following cases:

        ```python
        # returns a view to a piece of memory that is already dropped.
        pl.Series([1, 3, 5]).sort().view()

        # Sums invalid data that is missing.
        pl.Series([1, 2, None], nullable=True).view().sum()
        ```
        &quot;&quot;&quot;
        if not ignore_nulls:
            assert self.null_count() == 0

        ptr_type = dtype_to_ctype(self.dtype)
        ptr = self._s.as_single_ptr()
        array = _ptr_to_numpy(ptr, self.len(), ptr_type)
        array.setflags(write=False)
        return array

    def __array_ufunc__(
        self, ufunc: Callable[..., Any], method: str, *inputs: Any, **kwargs: Any
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Numpy universal functions.
        &quot;&quot;&quot;
        if self._s.n_chunks() &gt; 0:
            self._s.rechunk(in_place=True)

        if method == &quot;__call__&quot;:
            args: tp.List[Union[Number, np.ndarray]] = []
            for arg in inputs:
                if isinstance(arg, Number):
                    args.append(arg)
                elif isinstance(arg, Series):
                    args.append(arg.view(ignore_nulls=True))
                else:
                    return NotImplemented

            if &quot;dtype&quot; in kwargs:
                dtype = kwargs.pop(&quot;dtype&quot;)
            else:
                dtype = self.dtype

            f = get_ffi_func(&quot;apply_ufunc_&lt;&gt;&quot;, dtype, self._s)
            series = f(lambda out: ufunc(*args, out=out, **kwargs))
            return wrap_s(series)
        else:
            return NotImplemented

    def to_numpy(
        self, *args: Any, zero_copy_only: bool = False, **kwargs: Any
    ) -&gt; np.ndarray:
        &quot;&quot;&quot;
        Convert this Series to numpy. This operation clones data but is completely safe.

        If you want a zero-copy view and know what you are doing, use `.view()`.

        Parameters
        ----------
        args
            args will be sent to pyarrow.Array.to_numpy.
        zero_copy_only
            If True, an exception will be raised if the conversion to a numpy
            array would require copying the underlying data (e.g. in presence
            of nulls, or for non-primitive types).
        kwargs
            kwargs will be sent to pyarrow.Array.to_numpy
        &quot;&quot;&quot;
        return self.to_arrow().to_numpy(*args, zero_copy_only=zero_copy_only, **kwargs)

    def to_arrow(self) -&gt; pa.Array:
        &quot;&quot;&quot;
        Get the underlying arrow array. If the Series contains only a single chunk
        this operation is zero copy.
        &quot;&quot;&quot;
        return self._s.to_arrow()

    def set(self, filter: &quot;Series&quot;, value: Union[int, float]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Set masked values.

        Parameters
        ----------
        filter
            Boolean mask.
        value
            Value to replace the the masked values with.
        &quot;&quot;&quot;
        f = get_ffi_func(&quot;set_with_mask_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(filter._s, value))

    def set_at_idx(
        self, idx: Union[&quot;Series&quot;, np.ndarray], value: Union[int, float]
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Set values at the index locations.

        Parameters
        ----------
        idx
            Integers representing the index locations.
        value
            replacement values.

        Returns
        -------
        New allocated Series
        &quot;&quot;&quot;
        f = get_ffi_func(&quot;set_at_idx_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        if isinstance(idx, Series):
            idx_array = idx.view()
        elif isinstance(idx, np.ndarray):
            if not idx.data.c_contiguous:
                idx_array = np.ascontiguousarray(idx, dtype=np.uint64)
            else:
                idx_array = idx
                if idx_array.dtype != np.uint64:
                    idx_array = np.array(idx_array, np.uint64)

        else:
            idx_array = np.array(idx, dtype=np.uint64)

        return wrap_s(f(idx_array, value))

    def clone(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Cheap deep clones.
        &quot;&quot;&quot;
        return wrap_s(self._s.clone())

    def fill_none(self, strategy: str) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Fill null values with a filling strategy.

        Parameters
        ----------
        strategy
               * &quot;backward&quot;
               * &quot;forward&quot;
               * &quot;min&quot;
               * &quot;max&quot;
               * &quot;mean&quot;
               * &quot;one&quot;
               * &quot;zero&quot;
        &quot;&quot;&quot;
        return wrap_s(self._s.fill_none(strategy))

    def round(self, decimals: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Round underlying floating point data by `decimals` digits.

        Parameters
        ----------
        decimals
            number of decimals to round by.
        &quot;&quot;&quot;
        return wrap_s(self._s.round(decimals))

    def dot(self, other: &quot;Series&quot;) -&gt; Optional[float]:
        &quot;&quot;&quot;
        Compute the dot/inner product between two Series

        Parameters
        ----------
        other
            Series to compute dot product with
        &quot;&quot;&quot;
        return self._s.dot(other._s)

    def apply(
        self,
        func: Callable[[Any], Any],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a function over elements in this Series and return a new Series.

        If the function returns another datatype, the return_dtype arg should be set, otherwise the method will fail.

        Parameters
        ----------
        func
            function or lambda.
        return_dtype
            Output datatype. If none is given, the same datatype as this Series will be used.

        Returns
        -------
        Series
        &quot;&quot;&quot;
        if return_dtype == str:
            return_dtype = Utf8
        elif return_dtype == int:
            return_dtype = Int64
        elif return_dtype == float:
            return_dtype = Float64
        elif return_dtype == bool:
            return_dtype = Boolean

        return wrap_s(self._s.apply_lambda(func, return_dtype))

    def shift(self, periods: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with `Nones`.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        &quot;&quot;&quot;
        return wrap_s(self._s.shift(periods))

    def zip_with(self, mask: &quot;Series&quot;, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Where mask evaluates true, take values from self. Where mask evaluates false, take values from other.

        Parameters
        ----------
        mask
            Boolean Series.
        other
            Series of same type.

        Returns
        -------
        New Series
        &quot;&quot;&quot;
        return wrap_s(self._s.zip_with(mask._s, other._s))

    def as_duration(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        .. deprecated::
        If Series is a date32 or a date64 it can be turned into a duration.
        &quot;&quot;&quot;
        return wrap_s(self._s.as_duration())

    def rolling_min(
        self,
        window_size: int,
        weight: Optional[tp.List[float]] = None,
        ignore_null: bool = True,
        min_periods: Optional[int] = None,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        apply a rolling min (moving min) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        window_size
            The length of the window.
        weight
            An optional slice with the same length of the window that will be multiplied
            elementwise with the values in the window.
        ignore_null
            Toggle behavior of aggregation regarding null values in the window.
              `True` -&gt; Null values will be ignored.
              `False` -&gt; Any Null in the window leads to a Null in the aggregation result.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(
            self._s.rolling_min(window_size, weight, ignore_null, min_periods)
        )

    def rolling_max(
        self,
        window_size: int,
        weight: Optional[tp.List[float]] = None,
        ignore_null: bool = True,
        min_periods: Optional[int] = None,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a rolling max (moving max) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        window_size
            The length of the window.
        weight
            An optional slice with the same length of the window that will be multiplied
            elementwise with the values in the window.
        ignore_null
            Toggle behavior of aggregation regarding null values in the window.
              `True` -&gt; Null values will be ignored.
              `False` -&gt; Any Null in the window leads to a Null in the aggregation result.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(
            self._s.rolling_max(window_size, weight, ignore_null, min_periods)
        )

    def rolling_mean(
        self,
        window_size: int,
        weight: Optional[tp.List[float]] = None,
        ignore_null: bool = True,
        min_periods: Optional[int] = None,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a rolling mean (moving mean) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        window_size
            The length of the window.
        weight
            An optional slice with the same length of the window that will be multiplied
            elementwise with the values in the window.
        ignore_null
            Toggle behavior of aggregation regarding null values in the window.
              `True` -&gt; Null values will be ignored.
              `False` -&gt; Any Null in the window leads to a Null in the aggregation result.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(
            self._s.rolling_mean(window_size, weight, ignore_null, min_periods)
        )

    def rolling_sum(
        self,
        window_size: int,
        weight: Optional[tp.List[float]] = None,
        ignore_null: bool = True,
        min_periods: Optional[int] = None,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a rolling sum (moving sum) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        window_size
            The length of the window.
        weight
            An optional slice with the same length of the window that will be multiplied
            elementwise with the values in the window.
        ignore_null
            Toggle behavior of aggregation regarding null values in the window.
              `True` -&gt; Null values will be ignored.
              `False` -&gt; Any Null in the window leads to a Null in the aggregation result.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(
            self._s.rolling_sum(window_size, weight, ignore_null, min_periods)
        )

    @staticmethod
    def parse_date(
        name: str, values: Sequence[str], dtype: Type[DataType], fmt: str
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        .. deprecated::
        &quot;&quot;&quot;
        f = get_ffi_func(&quot;parse_&lt;&gt;_from_str_slice&quot;, dtype, PySeries)
        if f is None:
            return NotImplemented
        return wrap_s(f(name, values, fmt))

    def sample(
        self,
        n: Optional[int] = None,
        frac: Optional[float] = None,
        with_replacement: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Sample from this Series by setting either `n` or `frac`.

        Parameters
        ----------
        n
            Number of samples &lt; self.len().
        frac
            Fraction between 0.0 and 1.0 .
        with_replacement
            sample with replacement.
        &quot;&quot;&quot;
        if n is not None:
            return wrap_s(self._s.sample_n(n, with_replacement))
        return wrap_s(self._s.sample_frac(frac, with_replacement))

    def peak_max(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a boolean mask of the local maximum peaks.
        &quot;&quot;&quot;
        return wrap_s(self._s.peak_max())

    def peak_min(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a boolean mask of the local minimum peaks.
        &quot;&quot;&quot;
        return wrap_s(self._s.peak_min())

    def n_unique(self) -&gt; int:
        &quot;&quot;&quot;
        Count the number of unique values in this Series.
        &quot;&quot;&quot;
        return self._s.n_unique()

    def shrink_to_fit(self, in_place: bool = False) -&gt; Optional[&quot;Series&quot;]:
        &quot;&quot;&quot;
        Shrink memory usage of this Series to fit the exact capacity needed to hold the data.
        &quot;&quot;&quot;
        if in_place:
            self._s.shrink_to_fit()
            return None
        else:
            series = self.clone()
            series._s.shrink_to_fit()
            return series

    @property
    def dt(self) -&gt; &quot;DateTimeNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all datetime related methods.
        &quot;&quot;&quot;
        return DateTimeNameSpace(self)

    @property
    def str(self) -&gt; &quot;StringNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all string related methods.
        &quot;&quot;&quot;
        return StringNameSpace(self)

    def hash(self, k0: int = 0, k1: int = 1, k2: int = 2, k3: int = 3) -&gt; &quot;pl.Series&quot;:
        &quot;&quot;&quot;
        Hash the Series.

        The hash value is of type `UInt64`

        Parameters
        ----------
        k0
            seed parameter
        k1
            seed parameter
        k2
            seed parameter
        k3
            seed parameter
        &quot;&quot;&quot;
        return wrap_s(self._s.hash(k0, k1, k2, k3))

    def reinterpret(self, signed: bool = True) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Reinterpret the underlying bits as a signed/unsigned integer.
        This operation is only allowed for 64bit integers. For lower bits integers,
        you can safely use that cast operation.

        Parameters
        ----------
        signed
            True -&gt; pl.Int64
            False -&gt; pl.UInt64
        &quot;&quot;&quot;
        return wrap_s(self._s.reinterpret(signed))
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<pre><code class="language-python">Series(name: OptionalUnion[str, ArrayLike], 
    values: OptionalArrayLike, 
    nullable: bool, 
    dtype: OptionalTypeDataType,)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(
        self,
        name: Optional[Union[str, ArrayLike]] = None,
        values: Optional[ArrayLike] = None,
        nullable: bool = True,
        dtype: Optional[Type[DataType]] = None,
    ):
        # Handle case where values are passed as the first argument
        if name is not None and not isinstance(name, str):
            if values is None:
                values = name
                name = None
            else:
                raise ValueError(&quot;Series name must be a string.&quot;)

        # TODO: Remove if-statement below once Series name is allowed to be None
        if name is None:
            name = &quot;&quot;

        self._s: PySeries

        # series path
        if isinstance(values, Series):
            values.rename(name, in_place=True)
            self._s = values._s
            return
        elif isinstance(values, pa.Array):
            self._s = self.from_arrow(name, values)._s
            return
        elif isinstance(values, dict):
            raise ValueError(
                f&quot;Constructing a Series with a dict is not supported for {values}&quot;
            )

        # Handle empty values in constructor
        if values is None:
            values = []
        if dtype is None and isinstance(values, Sequence) and len(values) == 0:
            dtype = Float32

        # castable to numpy
        if not isinstance(values, np.ndarray) and not nullable:
            values = np.array(values)

        # numpy path
        if isinstance(values, np.ndarray):
            if not values.data.contiguous:
                values = np.array(values)
            if len(values.shape) &gt; 1:
                self._s = PySeries.new_object(name, values)
                return
            dtype = values.dtype
            if dtype == np.int64:
                self._s = PySeries.new_i64(name, values)
            elif dtype == np.int32:
                self._s = PySeries.new_i32(name, values)
            elif dtype == np.int16:
                self._s = PySeries.new_i16(name, values)
            elif dtype == np.int8:
                self._s = PySeries.new_i8(name, values)
            elif dtype == np.float32:
                self._s = PySeries.new_f32(name, values, nullable)
            elif dtype == np.float64:
                self._s = PySeries.new_f64(name, values, nullable)
            elif isinstance(values[0], str):
                self._s = PySeries.new_str(name, values)
            elif dtype == bool:
                self._s = PySeries.new_bool(name, values)
            elif dtype == np.uint8:
                self._s = PySeries.new_u8(name, values)
            elif dtype == np.uint16:
                self._s = PySeries.new_u16(name, values)
            elif dtype == np.uint32:
                self._s = PySeries.new_u32(name, values)
            elif dtype == np.uint64:
                self._s = PySeries.new_u64(name, values)
            else:
                self._s = PySeries.new_object(name, values)
            return
        # sequence path
        else:
            if dtype is not None:
                if dtype == Date32:
                    self._s = PySeries.new_opt_i32(name, values)
                    self._s = self.cast(Date32)._s
                elif dtype == Date64:
                    self._s = PySeries.new_opt_i32(name, values)
                    self._s = self.cast(Date64)._s
                elif dtype == Int32:
                    self._s = PySeries.new_opt_i32(name, values)
                elif dtype == Int64:
                    self._s = PySeries.new_opt_i64(name, values)
                elif dtype == Float32:
                    self._s = PySeries.new_opt_f32(name, values)
                elif dtype == Float64:
                    self._s = PySeries.new_opt_f64(name, values)
                elif dtype == Boolean:
                    self._s = PySeries.new_opt_bool(name, values)
                elif dtype == Utf8:
                    self._s = PySeries.new_str(name, values)
                elif dtype == Int16:
                    self._s = PySeries.new_opt_i16(name, values)
                elif dtype == Int8:
                    self._s = PySeries.new_opt_i8(name, values)
                elif dtype == UInt8:
                    self._s = PySeries.new_opt_u8(name, values)
                elif dtype == UInt16:
                    self._s = PySeries.new_opt_u16(name, values)
                elif dtype == UInt32:
                    self._s = PySeries.new_opt_u32(name, values)
                elif dtype == UInt64:
                    self._s = PySeries.new_opt_u64(name, values)
                elif dtype == Object:
                    self._s = PySeries.new_object(name, values)
                else:
                    raise ValueError(f&quot;{dtype} not yet implemented&quot;)
            else:
                dtype = _find_first_non_none(values)
                # order is important as booleans are instance of int in python.
                if isinstance(dtype, bool):
                    self._s = PySeries.new_opt_bool(name, values)
                elif isinstance(dtype, int):
                    self._s = PySeries.new_opt_i64(name, values)
                elif isinstance(dtype, float):
                    self._s = PySeries.new_opt_f64(name, values)
                elif isinstance(dtype, str):
                    self._s = PySeries.new_str(name, values)
                elif isinstance(dtype, datetime):
                    arrow_array = pa.array(values)
                    s = pl.from_arrow(arrow_array)
                    self._s = s._s
                    self._s.rename(name)
                elif isinstance(dtype, date):
                    arrow_array = pa.array(values)
                    s = pl.from_arrow(arrow_array)
                    self._s = s._s
                    self._s.rename(name)
                # make list array
                elif isinstance(dtype, (list, tuple)):
                    value_dtype = _find_first_non_none(dtype)

                    # we can expect a failure if we pass `[[12], &quot;foo&quot;, 9]`
                    # in that case we catch the exception and create an object type
                    try:
                        if isinstance(value_dtype, bool):
                            arrow_array = pa.array(values, pa.large_list(pa.bool_()))
                        elif isinstance(value_dtype, int):
                            arrow_array = pa.array(values, pa.large_list(pa.int64()))
                        elif isinstance(value_dtype, float):
                            arrow_array = pa.array(values, pa.large_list(pa.float64()))
                        elif isinstance(value_dtype, str):
                            arrow_array = pa.array(
                                values, pa.large_list(pa.large_utf8())
                            )
                        else:
                            self._s = PySeries.new_object(name, values)
                            return
                        self._s = Series.from_arrow(name, arrow_array)._s

                    except pa.lib.ArrowInvalid:
                        self._s = PySeries.new_object(name, values)
                else:
                    self._s = PySeries.new_object(name, values)
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesfrom_arrow"><a class="header" href="#polarseagerseriesseriesfrom_arrow"><code>polars.eager.series.Series.from_arrow</code></a></h3>
<pre><code class="language-python">from_arrow(name: str, array: pa.Array) -&gt; Series:
</code></pre>
<p>Create a Series from an arrow array.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: name of the Series.</li>
<li>[<code>array</code>]: Arrow array.</li>
</ul>
<p><strong>Decoration</strong> via <code>@staticmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def from_arrow(name: str, array: pa.Array) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Create a Series from an arrow array.

        Parameters
        ----------
        name
            name of the Series.
        array
            Arrow array.
        &quot;&quot;&quot;
        array = coerce_arrow(array)
        return Series._from_pyseries(PySeries.from_arrow(name, array))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesinner"><a class="header" href="#polarseagerseriesseriesinner"><code>polars.eager.series.Series.inner</code></a></h3>
<pre><code class="language-python">inner() -&gt; PySeries:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def inner(self) -&gt; &quot;PySeries&quot;:
        return self._s
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesdrop_nulls"><a class="header" href="#polarseagerseriesseriesdrop_nulls"><code>polars.eager.series.Series.drop_nulls</code></a></h3>
<pre><code class="language-python">drop_nulls() -&gt; Series:
</code></pre>
<p>Create a new Series that copies data from this Series without null values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def drop_nulls(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Create a new Series that copies data from this Series without null values.
        &quot;&quot;&quot;
        return wrap_s(self._s.drop_nulls())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesto_frame"><a class="header" href="#polarseagerseriesseriesto_frame"><code>polars.eager.series.Series.to_frame</code></a></h3>
<pre><code class="language-python">to_frame() -&gt; pl.DataFrame:
</code></pre>
<p>Cast this Series to a DataFrame.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_frame(self) -&gt; &quot;pl.DataFrame&quot;:
        &quot;&quot;&quot;
        Cast this Series to a DataFrame.
        &quot;&quot;&quot;
        return pl.eager.frame.wrap_df(PyDataFrame([self._s]))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesdtype"><a class="header" href="#polarseagerseriesseriesdtype"><code>polars.eager.series.Series.dtype</code></a></h3>
<pre><code class="language-python">dtype() -&gt; TypeDataType:
</code></pre>
<p>Get the data type of this Series.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def dtype(self) -&gt; Type[DataType]:
        &quot;&quot;&quot;
        Get the data type of this Series.
        &quot;&quot;&quot;
        return DTYPES[self._s.dtype()]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesdescribe"><a class="header" href="#polarseagerseriesseriesdescribe"><code>polars.eager.series.Series.describe</code></a></h3>
<pre><code class="language-python">describe() -&gt; Dict[str, Union[int, float]]:
</code></pre>
<p>Quick summary statistics of a series. Series with mixed datatypes will return summary statistics for the datatype of the first value.</p>
<p><strong>Returns:</strong></p>
<p>Dictionary with summary statistics of a series.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; series_num = pl.Series([1, 2, 3, 4, 5])
&gt;&gt;&gt; series_num.describe()
{'min': 1, 'max': 5, 'sum': 15, 'mean': 3.0, 'std': 1.4142135623730951, 'count': 5}

&gt;&gt;&gt; series_str = pl.Series([&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
&gt;&gt;&gt; series_str.describe()
{'unique': 3, 'count': 4}
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def describe(self) -&gt; Dict[str, Union[int, float]]:
        &quot;&quot;&quot;
        Quick summary statistics of a series. Series with mixed datatypes will return summary statistics for the datatype of the first value.

        Returns
        ---
        Dictionary with summary statistics of a series.

        Example
        ---
        ```python
        &gt;&gt;&gt; series_num = pl.Series([1, 2, 3, 4, 5])
        &gt;&gt;&gt; series_num.describe()
        {'min': 1, 'max': 5, 'sum': 15, 'mean': 3.0, 'std': 1.4142135623730951, 'count': 5}

        &gt;&gt;&gt; series_str = pl.Series([&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
        &gt;&gt;&gt; series_str.describe()
        {'unique': 3, 'count': 4}
        ```
        &quot;&quot;&quot;
        if len(self) == 0:
            raise ValueError(&quot;Series must contain at least one value&quot;)
        elif self.is_numeric():
            return {
                &quot;min&quot;: self.min(),
                &quot;max&quot;: self.max(),
                &quot;sum&quot;: self.sum(),
                &quot;mean&quot;: self.mean(),
                &quot;std&quot;: self.std(),
                &quot;count&quot;: len(self),
            }
        elif self.is_boolean():
            return {&quot;sum&quot;: self.sum(), &quot;count&quot;: len(self)}
        elif self.is_utf8():
            return {&quot;unique&quot;: len(self.unique()), &quot;count&quot;: len(self)}
        else:
            raise TypeError(&quot;This type is not supported&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriessum"><a class="header" href="#polarseagerseriesseriessum"><code>polars.eager.series.Series.sum</code></a></h3>
<pre><code class="language-python">sum() -&gt; Union[int, float]:
</code></pre>
<p>Reduce this Series to the sum value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sum(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Reduce this Series to the sum value.
        &quot;&quot;&quot;
        return self._s.sum()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesmean"><a class="header" href="#polarseagerseriesseriesmean"><code>polars.eager.series.Series.mean</code></a></h3>
<pre><code class="language-python">mean() -&gt; Union[int, float]:
</code></pre>
<p>Reduce this Series to the mean value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mean(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Reduce this Series to the mean value.
        &quot;&quot;&quot;
        return self._s.mean()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesmin"><a class="header" href="#polarseagerseriesseriesmin"><code>polars.eager.series.Series.min</code></a></h3>
<pre><code class="language-python">min() -&gt; Union[int, float]:
</code></pre>
<p>Get the minimal value in this Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def min(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Get the minimal value in this Series.
        &quot;&quot;&quot;
        return self._s.min()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesmax"><a class="header" href="#polarseagerseriesseriesmax"><code>polars.eager.series.Series.max</code></a></h3>
<pre><code class="language-python">max() -&gt; Union[int, float]:
</code></pre>
<p>Get the maximum value in this Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def max(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Get the maximum value in this Series.
        &quot;&quot;&quot;
        return self._s.max()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesstd"><a class="header" href="#polarseagerseriesseriesstd"><code>polars.eager.series.Series.std</code></a></h3>
<pre><code class="language-python">std(ddof: int) -&gt; float:
</code></pre>
<p>Get the standard deviation of this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>ddof</code>]: “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof,
where N represents the number of elements.
By default ddof is 1.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def std(self, ddof: int = 1) -&gt; float:
        &quot;&quot;&quot;
        Get the standard deviation of this Series.

        Parameters
        ----------
        ddof
            “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof,
            where N represents the number of elements.
            By default ddof is 1.
        &quot;&quot;&quot;
        return np.std(self.drop_nulls().view(), ddof=ddof)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesvar"><a class="header" href="#polarseagerseriesseriesvar"><code>polars.eager.series.Series.var</code></a></h3>
<pre><code class="language-python">var(ddof: int) -&gt; float:
</code></pre>
<p>Get variance of this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>ddof</code>]: “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof,
where N represents the number of elements.
By default ddof is 1.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def var(self, ddof: int = 1) -&gt; float:
        &quot;&quot;&quot;
        Get variance of this Series.

        Parameters
        ----------
        ddof
            “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof,
            where N represents the number of elements.
            By default ddof is 1.
        &quot;&quot;&quot;
        return np.var(self.drop_nulls().view(), ddof=ddof)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesmedian"><a class="header" href="#polarseagerseriesseriesmedian"><code>polars.eager.series.Series.median</code></a></h3>
<pre><code class="language-python">median() -&gt; float:
</code></pre>
<p>Get the median of this Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def median(self) -&gt; float:
        &quot;&quot;&quot;
        Get the median of this Series.
        &quot;&quot;&quot;
        return self._s.median()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesquantile"><a class="header" href="#polarseagerseriesseriesquantile"><code>polars.eager.series.Series.quantile</code></a></h3>
<pre><code class="language-python">quantile(quantile: float) -&gt; float:
</code></pre>
<p>Get the quantile value of this Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def quantile(self, quantile: float) -&gt; float:
        &quot;&quot;&quot;
        Get the quantile value of this Series.
        &quot;&quot;&quot;
        return self._s.quantile(quantile)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesto_dummies"><a class="header" href="#polarseagerseriesseriesto_dummies"><code>polars.eager.series.Series.to_dummies</code></a></h3>
<pre><code class="language-python">to_dummies() -&gt; pl.DataFrame:
</code></pre>
<p>Get dummy variables.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_dummies(self) -&gt; &quot;pl.DataFrame&quot;:
        &quot;&quot;&quot;
        Get dummy variables.
        &quot;&quot;&quot;
        return pl.eager.frame.wrap_df(self._s.to_dummies())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesvalue_counts"><a class="header" href="#polarseagerseriesseriesvalue_counts"><code>polars.eager.series.Series.value_counts</code></a></h3>
<pre><code class="language-python">value_counts() -&gt; pl.DataFrame:
</code></pre>
<p>Count the unique values in a Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def value_counts(self) -&gt; &quot;pl.DataFrame&quot;:
        &quot;&quot;&quot;
        Count the unique values in a Series.
        &quot;&quot;&quot;
        return pl.eager.frame.wrap_df(self._s.value_counts())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesname"><a class="header" href="#polarseagerseriesseriesname"><code>polars.eager.series.Series.name</code></a></h3>
<pre><code class="language-python">name() -&gt; str:
</code></pre>
<p>Get the name of this Series.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def name(self) -&gt; str:
        &quot;&quot;&quot;
        Get the name of this Series.
        &quot;&quot;&quot;
        return self._s.name()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesrename"><a class="header" href="#polarseagerseriesseriesrename"><code>polars.eager.series.Series.rename</code></a></h3>
<pre><code class="language-python">rename(name: str, in_place: bool) -&gt; OptionalSeries:
</code></pre>
<p>Rename this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: New name.</li>
<li>[<code>in_place</code>]: Modify the Series in-place.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rename(self, name: str, in_place: bool = False) -&gt; Optional[&quot;Series&quot;]:
        &quot;&quot;&quot;
        Rename this Series.

        Parameters
        ----------
        name
            New name.
        in_place
            Modify the Series in-place.
        &quot;&quot;&quot;
        if in_place:
            self._s.rename(name)
            return None
        else:
            s = self.clone()
            s._s.rename(name)
            return s
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesserieschunk_lengths"><a class="header" href="#polarseagerseriesserieschunk_lengths"><code>polars.eager.series.Series.chunk_lengths</code></a></h3>
<pre><code class="language-python">chunk_lengths() -&gt; tp.List[int]:
</code></pre>
<p>Get the length of each individual chunk.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def chunk_lengths(self) -&gt; tp.List[int]:
        &quot;&quot;&quot;
        Get the length of each individual chunk.
        &quot;&quot;&quot;
        return self._s.chunk_lengths()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesn_chunks"><a class="header" href="#polarseagerseriesseriesn_chunks"><code>polars.eager.series.Series.n_chunks</code></a></h3>
<pre><code class="language-python">n_chunks() -&gt; int:
</code></pre>
<p>Get the number of chunks that this Series contains.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def n_chunks(self) -&gt; int:
        &quot;&quot;&quot;
        Get the number of chunks that this Series contains.
        &quot;&quot;&quot;
        return self._s.n_chunks()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriescum_sum"><a class="header" href="#polarseagerseriesseriescum_sum"><code>polars.eager.series.Series.cum_sum</code></a></h3>
<pre><code class="language-python">cum_sum(reverse: bool) -&gt; Union[int, float]:
</code></pre>
<p>Get an array with the cumulative sum computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: reverse the operation.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cum_sum(self, reverse: bool = False) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Get an array with the cumulative sum computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.
        &quot;&quot;&quot;
        return self._s.cum_sum(reverse)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriescum_min"><a class="header" href="#polarseagerseriesseriescum_min"><code>polars.eager.series.Series.cum_min</code></a></h3>
<pre><code class="language-python">cum_min(reverse: bool) -&gt; Union[int, float]:
</code></pre>
<p>Get an array with the cumulative min computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: reverse the operation.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cum_min(self, reverse: bool = False) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Get an array with the cumulative min computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.
        &quot;&quot;&quot;
        return self._s.cum_min(reverse)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriescum_max"><a class="header" href="#polarseagerseriesseriescum_max"><code>polars.eager.series.Series.cum_max</code></a></h3>
<pre><code class="language-python">cum_max(reverse: bool) -&gt; Union[int, float]:
</code></pre>
<p>Get an array with the cumulative max computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: reverse the operation.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cum_max(self, reverse: bool = False) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Get an array with the cumulative max computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.
        &quot;&quot;&quot;
        return self._s.cum_max(reverse)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesserieslimit"><a class="header" href="#polarseagerseriesserieslimit"><code>polars.eager.series.Series.limit</code></a></h3>
<pre><code class="language-python">limit(num_elements: int) -&gt; Series:
</code></pre>
<p>Take n elements from this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>num_elements</code>]: Amount of elements to take.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def limit(self, num_elements: int = 10) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take n elements from this Series.

        Parameters
        ----------
        num_elements
            Amount of elements to take.
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.limit(num_elements))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesslice"><a class="header" href="#polarseagerseriesseriesslice"><code>polars.eager.series.Series.slice</code></a></h3>
<pre><code class="language-python">slice(offset: int, length: int) -&gt; Series:
</code></pre>
<p>Get a slice of this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>offset</code>]: Offset index.</li>
<li>[<code>length</code>]: Length of the slice.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def slice(self, offset: int, length: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a slice of this Series.

        Parameters
        ----------
        offset
            Offset index.
        length
            Length of the slice.
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.slice(offset, length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesappend"><a class="header" href="#polarseagerseriesseriesappend"><code>polars.eager.series.Series.append</code></a></h3>
<pre><code class="language-python">append(other: Series) -&gt; None:
</code></pre>
<p>Append a Series to this one.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: Series to append.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def append(self, other: &quot;Series&quot;) -&gt; None:
        &quot;&quot;&quot;
        Append a Series to this one.

        Parameters
        ----------
        other
            Series to append.
        &quot;&quot;&quot;
        self._s.append(other._s)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesfilter"><a class="header" href="#polarseagerseriesseriesfilter"><code>polars.eager.series.Series.filter</code></a></h3>
<pre><code class="language-python">filter(predicate: Series) -&gt; Series:
</code></pre>
<p>Filter elements by a boolean mask.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>predicate</code>]: Boolean mask.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def filter(self, predicate: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Filter elements by a boolean mask.

        Parameters
        ----------
        predicate
            Boolean mask.
        &quot;&quot;&quot;
        if isinstance(predicate, list):
            predicate = Series(&quot;&quot;, predicate)
        return Series._from_pyseries(self._s.filter(predicate._s))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesserieshead"><a class="header" href="#polarseagerseriesserieshead"><code>polars.eager.series.Series.head</code></a></h3>
<pre><code class="language-python">head(length: Optionalint) -&gt; Series:
</code></pre>
<p>Get first N elements as Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>length</code>]: Length of the head.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def head(self, length: Optional[int] = None) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get first N elements as Series.

        Parameters
        ----------
        length
            Length of the head.
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.head(length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriestail"><a class="header" href="#polarseagerseriesseriestail"><code>polars.eager.series.Series.tail</code></a></h3>
<pre><code class="language-python">tail(length: Optionalint) -&gt; Series:
</code></pre>
<p>Get last N elements as Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>length</code>]: Length of the tail.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def tail(self, length: Optional[int] = None) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get last N elements as Series.

        Parameters
        ----------
        length
            Length of the tail.
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.tail(length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriestake_every"><a class="header" href="#polarseagerseriesseriestake_every"><code>polars.eager.series.Series.take_every</code></a></h3>
<pre><code class="language-python">take_every(n: int) -&gt; Series:
</code></pre>
<p>Take every nth value in the Series and return as new Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def take_every(self, n: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take every nth value in the Series and return as new Series.
        &quot;&quot;&quot;
        return wrap_s(self._s.take_every(n))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriessort"><a class="header" href="#polarseagerseriesseriessort"><code>polars.eager.series.Series.sort</code></a></h3>
<pre><code class="language-python">sort(in_place: bool, reverse: bool) -&gt; OptionalSeries:
</code></pre>
<p>Sort this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>in_place</code>]: Sort in place.</li>
<li>[<code>reverse</code>]: Reverse sort.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sort(self, in_place: bool = False, reverse: bool = False) -&gt; Optional[&quot;Series&quot;]:
        &quot;&quot;&quot;
        Sort this Series.

        Parameters
        ----------
        in_place
            Sort in place.
        reverse
            Reverse sort.
        &quot;&quot;&quot;
        if in_place:
            self._s.sort_in_place(reverse)
            return None
        else:
            return wrap_s(self._s.sort(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesargsort"><a class="header" href="#polarseagerseriesseriesargsort"><code>polars.eager.series.Series.argsort</code></a></h3>
<pre><code class="language-python">argsort(reverse: bool) -&gt; Series:
</code></pre>
<p>..deprecate::</p>
<p>Index location of the sorted variant of this Series.</p>
<p><strong>Returns:</strong></p>
<ul>
<li>[<code>indexes</code>]: Indexes that can be used to sort this array.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def argsort(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        ..deprecate::

        Index location of the sorted variant of this Series.

        Returns
        -------
        indexes
            Indexes that can be used to sort this array.
        &quot;&quot;&quot;
        return wrap_s(self._s.argsort(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesarg_sort"><a class="header" href="#polarseagerseriesseriesarg_sort"><code>polars.eager.series.Series.arg_sort</code></a></h3>
<pre><code class="language-python">arg_sort(reverse: bool) -&gt; Series:
</code></pre>
<p>Index location of the sorted variant of this Series.</p>
<p><strong>Returns:</strong></p>
<ul>
<li>[<code>indexes</code>]: Indexes that can be used to sort this array.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_sort(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Index location of the sorted variant of this Series.

        Returns
        -------
        indexes
            Indexes that can be used to sort this array.
        &quot;&quot;&quot;
        return wrap_s(self._s.argsort(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesarg_unique"><a class="header" href="#polarseagerseriesseriesarg_unique"><code>polars.eager.series.Series.arg_unique</code></a></h3>
<pre><code class="language-python">arg_unique() -&gt; Series:
</code></pre>
<p>Get unique index as Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_unique(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get unique index as Series.
        &quot;&quot;&quot;
        return self._s.arg_unique()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesarg_min"><a class="header" href="#polarseagerseriesseriesarg_min"><code>polars.eager.series.Series.arg_min</code></a></h3>
<pre><code class="language-python">arg_min() -&gt; Optionalint:
</code></pre>
<p>Get the index of the minimal value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_min(self) -&gt; Optional[int]:
        &quot;&quot;&quot;
        Get the index of the minimal value.
        &quot;&quot;&quot;
        return self._s.arg_min()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesarg_max"><a class="header" href="#polarseagerseriesseriesarg_max"><code>polars.eager.series.Series.arg_max</code></a></h3>
<pre><code class="language-python">arg_max() -&gt; Optionalint:
</code></pre>
<p>Get the index of the maxima value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_max(self) -&gt; Optional[int]:
        &quot;&quot;&quot;
        Get the index of the maxima value.
        &quot;&quot;&quot;
        return self._s.arg_max()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesunique"><a class="header" href="#polarseagerseriesseriesunique"><code>polars.eager.series.Series.unique</code></a></h3>
<pre><code class="language-python">unique() -&gt; Series:
</code></pre>
<p>Get unique elements in series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def unique(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get unique elements in series.
        &quot;&quot;&quot;
        return wrap_s(self._s.unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriestake"><a class="header" href="#polarseagerseriesseriestake"><code>polars.eager.series.Series.take</code></a></h3>
<pre><code class="language-python">take(indices: Union[np.ndarray, tp.List[int]],) -&gt; Series:
</code></pre>
<p>Take values by index.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>indices</code>]: Index location used for selection.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def take(self, indices: Union[np.ndarray, tp.List[int]]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take values by index.

        Parameters
        ----------
        indices
            Index location used for selection.
        &quot;&quot;&quot;
        if isinstance(indices, list):
            indices = np.array(indices)
        return Series._from_pyseries(self._s.take(indices))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesnull_count"><a class="header" href="#polarseagerseriesseriesnull_count"><code>polars.eager.series.Series.null_count</code></a></h3>
<pre><code class="language-python">null_count() -&gt; int:
</code></pre>
<p>Count the null values in this Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def null_count(self) -&gt; int:
        &quot;&quot;&quot;
        Count the null values in this Series.
        &quot;&quot;&quot;
        return self._s.null_count()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesis_null"><a class="header" href="#polarseagerseriesseriesis_null"><code>polars.eager.series.Series.is_null</code></a></h3>
<pre><code class="language-python">is_null() -&gt; Series:
</code></pre>
<p>Get mask of null values.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_null(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of null values.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_null())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesis_not_null"><a class="header" href="#polarseagerseriesseriesis_not_null"><code>polars.eager.series.Series.is_not_null</code></a></h3>
<pre><code class="language-python">is_not_null() -&gt; Series:
</code></pre>
<p>Get mask of non null values.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_not_null(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of non null values.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_not_null())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesis_finite"><a class="header" href="#polarseagerseriesseriesis_finite"><code>polars.eager.series.Series.is_finite</code></a></h3>
<pre><code class="language-python">is_finite() -&gt; Series:
</code></pre>
<p>Get mask of finite values if Series dtype is Float.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_finite(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of finite values if Series dtype is Float.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_finite())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesis_infinite"><a class="header" href="#polarseagerseriesseriesis_infinite"><code>polars.eager.series.Series.is_infinite</code></a></h3>
<pre><code class="language-python">is_infinite() -&gt; Series:
</code></pre>
<p>Get mask of infinite values if Series dtype is Float.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_infinite(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of infinite values if Series dtype is Float.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_infinite())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesis_nan"><a class="header" href="#polarseagerseriesseriesis_nan"><code>polars.eager.series.Series.is_nan</code></a></h3>
<pre><code class="language-python">is_nan() -&gt; Series:
</code></pre>
<p>Get mask of NaN values if Series dtype is Float.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_nan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of NaN values if Series dtype is Float.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_nan())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesis_not_nan"><a class="header" href="#polarseagerseriesseriesis_not_nan"><code>polars.eager.series.Series.is_not_nan</code></a></h3>
<pre><code class="language-python">is_not_nan() -&gt; Series:
</code></pre>
<p>Get negated mask of NaN values if Series dtype is_not Float.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_not_nan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get negated mask of NaN values if Series dtype is_not Float.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_not_nan())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesis_in"><a class="header" href="#polarseagerseriesseriesis_in"><code>polars.eager.series.Series.is_in</code></a></h3>
<pre><code class="language-python">is_in(other: Series) -&gt; Series:
</code></pre>
<p>Check if elements of this Series are in the right Series, or List values of the right Series.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_in(self, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Check if elements of this Series are in the right Series, or List values of the right Series.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        if type(other) is list:
            other = Series(&quot;&quot;, other)
        return wrap_s(self._s.is_in(other._s))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesarg_true"><a class="header" href="#polarseagerseriesseriesarg_true"><code>polars.eager.series.Series.arg_true</code></a></h3>
<pre><code class="language-python">arg_true() -&gt; Series:
</code></pre>
<p>Get index values where Boolean Series evaluate True.</p>
<p><strong>Returns:</strong></p>
<p>UInt32 Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_true(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get index values where Boolean Series evaluate True.

        Returns
        -------
        UInt32 Series
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.arg_true())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesis_unique"><a class="header" href="#polarseagerseriesseriesis_unique"><code>polars.eager.series.Series.is_unique</code></a></h3>
<pre><code class="language-python">is_unique() -&gt; Series:
</code></pre>
<p>Get mask of all unique values.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_unique(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of all unique values.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return wrap_s(self._s.is_unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesis_first"><a class="header" href="#polarseagerseriesseriesis_first"><code>polars.eager.series.Series.is_first</code></a></h3>
<pre><code class="language-python">is_first() -&gt; Series:
</code></pre>
<p>Get a mask of the first unique value.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_first(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a mask of the first unique value.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return wrap_s(self._s.is_first())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesis_duplicated"><a class="header" href="#polarseagerseriesseriesis_duplicated"><code>polars.eager.series.Series.is_duplicated</code></a></h3>
<pre><code class="language-python">is_duplicated() -&gt; Series:
</code></pre>
<p>Get mask of all duplicated values.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_duplicated(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of all duplicated values.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return wrap_s(self._s.is_duplicated())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesexplode"><a class="header" href="#polarseagerseriesseriesexplode"><code>polars.eager.series.Series.explode</code></a></h3>
<pre><code class="language-python">explode() -&gt; Series:
</code></pre>
<p>Explode a list or utf8 Series. This means that every item is expanded to a new row.</p>
<p><strong>Returns:</strong></p>
<p>Exploded Series of same dtype</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def explode(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Explode a list or utf8 Series. This means that every item is expanded to a new row.

        Returns
        -------
        Exploded Series of same dtype
        &quot;&quot;&quot;
        return wrap_s(self._s.explode())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesseries_equal"><a class="header" href="#polarseagerseriesseriesseries_equal"><code>polars.eager.series.Series.series_equal</code></a></h3>
<pre><code class="language-python">series_equal(other: Series, null_equal: bool) -&gt; bool:
</code></pre>
<p>Check if series is equal with another Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: Series to compare with.</li>
<li>[<code>null_equal</code>]: Consider null values as equal.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def series_equal(self, other: &quot;Series&quot;, null_equal: bool = False) -&gt; bool:
        &quot;&quot;&quot;
        Check if series is equal with another Series.

        Parameters
        ----------
        other
            Series to compare with.
        null_equal
            Consider null values as equal.
        &quot;&quot;&quot;
        return self._s.series_equal(other._s, null_equal)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesserieslen"><a class="header" href="#polarseagerseriesserieslen"><code>polars.eager.series.Series.len</code></a></h3>
<pre><code class="language-python">len() -&gt; int:
</code></pre>
<p>Length of this Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def len(self) -&gt; int:
        &quot;&quot;&quot;
        Length of this Series.
        &quot;&quot;&quot;
        return self._s.len()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesshape"><a class="header" href="#polarseagerseriesseriesshape"><code>polars.eager.series.Series.shape</code></a></h3>
<pre><code class="language-python">shape() -&gt; Tupleint:
</code></pre>
<p>Shape of this Series.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shape(self) -&gt; Tuple[int]:
        &quot;&quot;&quot;
        Shape of this Series.
        &quot;&quot;&quot;
        return (self._s.len(),)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriescast"><a class="header" href="#polarseagerseriesseriescast"><code>polars.eager.series.Series.cast</code></a></h3>
<pre><code class="language-python">cast(data_type: TypeDataType) -&gt; Series:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cast(self, data_type: Type[DataType]) -&gt; &quot;Series&quot;:
        if data_type == int:
            data_type = Int64
        elif data_type == str:
            data_type = Utf8
        elif data_type == float:
            data_type = Float64
        f = get_ffi_func(&quot;cast_&lt;&gt;&quot;, data_type, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesto_list"><a class="header" href="#polarseagerseriesseriesto_list"><code>polars.eager.series.Series.to_list</code></a></h3>
<pre><code class="language-python">to_list() -&gt; tp.List[OptionalAny]:
</code></pre>
<p>Convert this Series to a Python List. This operation clones data.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_list(self) -&gt; tp.List[Optional[Any]]:
        &quot;&quot;&quot;
        Convert this Series to a Python List. This operation clones data.
        &quot;&quot;&quot;
        if self.dtype != Object:
            return self.to_arrow().to_pylist()
        return self._s.to_list()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesrechunk"><a class="header" href="#polarseagerseriesseriesrechunk"><code>polars.eager.series.Series.rechunk</code></a></h3>
<pre><code class="language-python">rechunk(in_place: bool) -&gt; OptionalSeries:
</code></pre>
<p>Create a single chunk of memory for this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>in_place</code>]: In place or not.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rechunk(self, in_place: bool = False) -&gt; Optional[&quot;Series&quot;]:
        &quot;&quot;&quot;
        Create a single chunk of memory for this Series.

        Parameters
        ----------
        in_place
            In place or not.
        &quot;&quot;&quot;
        opt_s = self._s.rechunk(in_place)
        if in_place:
            return None
        else:
            return wrap_s(opt_s)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesis_numeric"><a class="header" href="#polarseagerseriesseriesis_numeric"><code>polars.eager.series.Series.is_numeric</code></a></h3>
<pre><code class="language-python">is_numeric() -&gt; bool:
</code></pre>
<p>Check if this Series datatype is numeric.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_numeric(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series datatype is numeric.
        &quot;&quot;&quot;
        return self.dtype in (
            Int8,
            Int16,
            Int32,
            Int64,
            UInt8,
            UInt16,
            UInt32,
            UInt64,
            Float32,
            Float64,
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesis_float"><a class="header" href="#polarseagerseriesseriesis_float"><code>polars.eager.series.Series.is_float</code></a></h3>
<pre><code class="language-python">is_float() -&gt; bool:
</code></pre>
<p>Check if this Series has floating point numbers.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_float(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series has floating point numbers.
        &quot;&quot;&quot;
        return self.dtype in (Float32, Float64)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesis_boolean"><a class="header" href="#polarseagerseriesseriesis_boolean"><code>polars.eager.series.Series.is_boolean</code></a></h3>
<pre><code class="language-python">is_boolean() -&gt; bool:
</code></pre>
<p>Check if this Series is a Boolean.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_boolean(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series is a Boolean.
        &quot;&quot;&quot;
        return self.dtype is Boolean
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesis_utf8"><a class="header" href="#polarseagerseriesseriesis_utf8"><code>polars.eager.series.Series.is_utf8</code></a></h3>
<pre><code class="language-python">is_utf8() -&gt; bool:
</code></pre>
<p>Checks if this Series datatype is a Utf8.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_utf8(self) -&gt; bool:
        &quot;&quot;&quot;
        Checks if this Series datatype is a Utf8.
        &quot;&quot;&quot;
        return self.dtype is Utf8
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesview"><a class="header" href="#polarseagerseriesseriesview"><code>polars.eager.series.Series.view</code></a></h3>
<pre><code class="language-python">view(ignore_nulls: bool) -&gt; np.ndarray:
</code></pre>
<p>Get a view into this Series data with a numpy array. This operation doesn't clone data, but does not include
missing values. Don't use this unless you know what you are doing.</p>
<p><strong>Safety:</strong>
.</p>
<p>This function can lead to undefined behavior in the following cases:</p>
<pre><code class="language-python"># returns a view to a piece of memory that is already dropped.
pl.Series([1, 3, 5]).sort().view()

# Sums invalid data that is missing.
pl.Series([1, 2, None], nullable=True).view().sum()
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def view(self, ignore_nulls: bool = False) -&gt; np.ndarray:
        &quot;&quot;&quot;
        Get a view into this Series data with a numpy array. This operation doesn't clone data, but does not include
        missing values. Don't use this unless you know what you are doing.

        # Safety.

        This function can lead to undefined behavior in the following cases:

        ```python
        # returns a view to a piece of memory that is already dropped.
        pl.Series([1, 3, 5]).sort().view()

        # Sums invalid data that is missing.
        pl.Series([1, 2, None], nullable=True).view().sum()
        ```
        &quot;&quot;&quot;
        if not ignore_nulls:
            assert self.null_count() == 0

        ptr_type = dtype_to_ctype(self.dtype)
        ptr = self._s.as_single_ptr()
        array = _ptr_to_numpy(ptr, self.len(), ptr_type)
        array.setflags(write=False)
        return array
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesto_numpy"><a class="header" href="#polarseagerseriesseriesto_numpy"><code>polars.eager.series.Series.to_numpy</code></a></h3>
<pre><code class="language-python">to_numpy(*args, **kwargs) -&gt; np.ndarray:
</code></pre>
<p>Convert this Series to numpy. This operation clones data but is completely safe.</p>
<p>If you want a zero-copy view and know what you are doing, use <code>.view()</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>args</code>]: args will be sent to pyarrow.Array.to_numpy.</li>
<li>[<code>zero_copy_only</code>]: If True, an exception will be raised if the conversion to a numpy
array would require copying the underlying data (e.g. in presence
of nulls, or for non-primitive types).</li>
<li>[<code>kwargs</code>]: kwargs will be sent to pyarrow.Array.to_numpy</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_numpy(
        self, *args: Any, zero_copy_only: bool = False, **kwargs: Any
    ) -&gt; np.ndarray:
        &quot;&quot;&quot;
        Convert this Series to numpy. This operation clones data but is completely safe.

        If you want a zero-copy view and know what you are doing, use `.view()`.

        Parameters
        ----------
        args
            args will be sent to pyarrow.Array.to_numpy.
        zero_copy_only
            If True, an exception will be raised if the conversion to a numpy
            array would require copying the underlying data (e.g. in presence
            of nulls, or for non-primitive types).
        kwargs
            kwargs will be sent to pyarrow.Array.to_numpy
        &quot;&quot;&quot;
        return self.to_arrow().to_numpy(*args, zero_copy_only=zero_copy_only, **kwargs)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesto_arrow"><a class="header" href="#polarseagerseriesseriesto_arrow"><code>polars.eager.series.Series.to_arrow</code></a></h3>
<pre><code class="language-python">to_arrow() -&gt; pa.Array:
</code></pre>
<p>Get the underlying arrow array. If the Series contains only a single chunk
this operation is zero copy.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_arrow(self) -&gt; pa.Array:
        &quot;&quot;&quot;
        Get the underlying arrow array. If the Series contains only a single chunk
        this operation is zero copy.
        &quot;&quot;&quot;
        return self._s.to_arrow()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesset"><a class="header" href="#polarseagerseriesseriesset"><code>polars.eager.series.Series.set</code></a></h3>
<pre><code class="language-python">set(filter: Series, 
    value: Union[int, float],) -&gt; Series:
</code></pre>
<p>Set masked values.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>filter</code>]: Boolean mask.</li>
<li>[<code>value</code>]: Value to replace the the masked values with.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def set(self, filter: &quot;Series&quot;, value: Union[int, float]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Set masked values.

        Parameters
        ----------
        filter
            Boolean mask.
        value
            Value to replace the the masked values with.
        &quot;&quot;&quot;
        f = get_ffi_func(&quot;set_with_mask_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(filter._s, value))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesset_at_idx"><a class="header" href="#polarseagerseriesseriesset_at_idx"><code>polars.eager.series.Series.set_at_idx</code></a></h3>
<pre><code class="language-python">set_at_idx(idx: Union[Series, np.ndarray], 
    value: Union[int, float],) -&gt; Series:
</code></pre>
<p>Set values at the index locations.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>idx</code>]: Integers representing the index locations.</li>
<li>[<code>value</code>]: replacement values.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>New allocated Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def set_at_idx(
        self, idx: Union[&quot;Series&quot;, np.ndarray], value: Union[int, float]
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Set values at the index locations.

        Parameters
        ----------
        idx
            Integers representing the index locations.
        value
            replacement values.

        Returns
        -------
        New allocated Series
        &quot;&quot;&quot;
        f = get_ffi_func(&quot;set_at_idx_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        if isinstance(idx, Series):
            idx_array = idx.view()
        elif isinstance(idx, np.ndarray):
            if not idx.data.c_contiguous:
                idx_array = np.ascontiguousarray(idx, dtype=np.uint64)
            else:
                idx_array = idx
                if idx_array.dtype != np.uint64:
                    idx_array = np.array(idx_array, np.uint64)

        else:
            idx_array = np.array(idx, dtype=np.uint64)

        return wrap_s(f(idx_array, value))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesclone"><a class="header" href="#polarseagerseriesseriesclone"><code>polars.eager.series.Series.clone</code></a></h3>
<pre><code class="language-python">clone() -&gt; Series:
</code></pre>
<p>Cheap deep clones.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def clone(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Cheap deep clones.
        &quot;&quot;&quot;
        return wrap_s(self._s.clone())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesfill_none"><a class="header" href="#polarseagerseriesseriesfill_none"><code>polars.eager.series.Series.fill_none</code></a></h3>
<pre><code class="language-python">fill_none(strategy: str) -&gt; Series:
</code></pre>
<p>Fill null values with a filling strategy.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<pre><code> * &quot;forward&quot;
 * &quot;min&quot;
 * &quot;max&quot;
 * &quot;mean&quot;
 * &quot;one&quot;
 * &quot;zero&quot;
</code></pre>
</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def fill_none(self, strategy: str) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Fill null values with a filling strategy.

        Parameters
        ----------
        strategy
               * &quot;backward&quot;
               * &quot;forward&quot;
               * &quot;min&quot;
               * &quot;max&quot;
               * &quot;mean&quot;
               * &quot;one&quot;
               * &quot;zero&quot;
        &quot;&quot;&quot;
        return wrap_s(self._s.fill_none(strategy))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesround"><a class="header" href="#polarseagerseriesseriesround"><code>polars.eager.series.Series.round</code></a></h3>
<pre><code class="language-python">round(decimals: int) -&gt; Series:
</code></pre>
<p>Round underlying floating point data by <code>decimals</code> digits.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>decimals</code>]: number of decimals to round by.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def round(self, decimals: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Round underlying floating point data by `decimals` digits.

        Parameters
        ----------
        decimals
            number of decimals to round by.
        &quot;&quot;&quot;
        return wrap_s(self._s.round(decimals))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesdot"><a class="header" href="#polarseagerseriesseriesdot"><code>polars.eager.series.Series.dot</code></a></h3>
<pre><code class="language-python">dot(other: Series) -&gt; Optionalfloat:
</code></pre>
<p>Compute the dot/inner product between two Series</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: Series to compute dot product with</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def dot(self, other: &quot;Series&quot;) -&gt; Optional[float]:
        &quot;&quot;&quot;
        Compute the dot/inner product between two Series

        Parameters
        ----------
        other
            Series to compute dot product with
        &quot;&quot;&quot;
        return self._s.dot(other._s)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesapply"><a class="header" href="#polarseagerseriesseriesapply"><code>polars.eager.series.Series.apply</code></a></h3>
<pre><code class="language-python">apply(func: Callable[[Any], Any], 
    return_dtype: OptionalTypeDataType,) -&gt; Series:
</code></pre>
<p>Apply a function over elements in this Series and return a new Series.</p>
<p>If the function returns another datatype, the return_dtype arg should be set, otherwise the method will fail.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>func</code>]: function or lambda.</li>
<li>[<code>return_dtype</code>]: Output datatype. If none is given, the same datatype as this Series will be used.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def apply(
        self,
        func: Callable[[Any], Any],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a function over elements in this Series and return a new Series.

        If the function returns another datatype, the return_dtype arg should be set, otherwise the method will fail.

        Parameters
        ----------
        func
            function or lambda.
        return_dtype
            Output datatype. If none is given, the same datatype as this Series will be used.

        Returns
        -------
        Series
        &quot;&quot;&quot;
        if return_dtype == str:
            return_dtype = Utf8
        elif return_dtype == int:
            return_dtype = Int64
        elif return_dtype == float:
            return_dtype = Float64
        elif return_dtype == bool:
            return_dtype = Boolean

        return wrap_s(self._s.apply_lambda(func, return_dtype))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesshift"><a class="header" href="#polarseagerseriesseriesshift"><code>polars.eager.series.Series.shift</code></a></h3>
<pre><code class="language-python">shift(periods: int) -&gt; Series:
</code></pre>
<p>Shift the values by a given period and fill the parts that will be empty due to this operation
with <code>Nones</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>periods</code>]: Number of places to shift (may be negative).</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shift(self, periods: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with `Nones`.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        &quot;&quot;&quot;
        return wrap_s(self._s.shift(periods))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesserieszip_with"><a class="header" href="#polarseagerseriesserieszip_with"><code>polars.eager.series.Series.zip_with</code></a></h3>
<pre><code class="language-python">zip_with(mask: Series, other: Series) -&gt; Series:
</code></pre>
<p>Where mask evaluates true, take values from self. Where mask evaluates false, take values from other.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>mask</code>]: Boolean Series.</li>
<li>[<code>other</code>]: Series of same type.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>New Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def zip_with(self, mask: &quot;Series&quot;, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Where mask evaluates true, take values from self. Where mask evaluates false, take values from other.

        Parameters
        ----------
        mask
            Boolean Series.
        other
            Series of same type.

        Returns
        -------
        New Series
        &quot;&quot;&quot;
        return wrap_s(self._s.zip_with(mask._s, other._s))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesas_duration"><a class="header" href="#polarseagerseriesseriesas_duration"><code>polars.eager.series.Series.as_duration</code></a></h3>
<pre><code class="language-python">as_duration() -&gt; Series:
</code></pre>
<p>.. deprecated::
If Series is a date32 or a date64 it can be turned into a duration.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def as_duration(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        .. deprecated::
        If Series is a date32 or a date64 it can be turned into a duration.
        &quot;&quot;&quot;
        return wrap_s(self._s.as_duration())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesrolling_min"><a class="header" href="#polarseagerseriesseriesrolling_min"><code>polars.eager.series.Series.rolling_min</code></a></h3>
<pre><code class="language-python">rolling_min(window_size: int, 
    weight: Optionaltp.List[float], 
    ignore_null: bool, 
    min_periods: Optionalint,) -&gt; Series:
</code></pre>
<p>apply a rolling min (moving min) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weight</code>]: An optional slice with the same length of the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>ignore_null</code>]: Toggle behavior of aggregation regarding null values in the window.
<code>True</code> -&gt; Null values will be ignored.
<code>False</code> -&gt; Any Null in the window leads to a Null in the aggregation result.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_min(
        self,
        window_size: int,
        weight: Optional[tp.List[float]] = None,
        ignore_null: bool = True,
        min_periods: Optional[int] = None,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        apply a rolling min (moving min) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        window_size
            The length of the window.
        weight
            An optional slice with the same length of the window that will be multiplied
            elementwise with the values in the window.
        ignore_null
            Toggle behavior of aggregation regarding null values in the window.
              `True` -&gt; Null values will be ignored.
              `False` -&gt; Any Null in the window leads to a Null in the aggregation result.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(
            self._s.rolling_min(window_size, weight, ignore_null, min_periods)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesrolling_max"><a class="header" href="#polarseagerseriesseriesrolling_max"><code>polars.eager.series.Series.rolling_max</code></a></h3>
<pre><code class="language-python">rolling_max(window_size: int, 
    weight: Optionaltp.List[float], 
    ignore_null: bool, 
    min_periods: Optionalint,) -&gt; Series:
</code></pre>
<p>Apply a rolling max (moving max) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weight</code>]: An optional slice with the same length of the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>ignore_null</code>]: Toggle behavior of aggregation regarding null values in the window.
<code>True</code> -&gt; Null values will be ignored.
<code>False</code> -&gt; Any Null in the window leads to a Null in the aggregation result.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_max(
        self,
        window_size: int,
        weight: Optional[tp.List[float]] = None,
        ignore_null: bool = True,
        min_periods: Optional[int] = None,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a rolling max (moving max) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        window_size
            The length of the window.
        weight
            An optional slice with the same length of the window that will be multiplied
            elementwise with the values in the window.
        ignore_null
            Toggle behavior of aggregation regarding null values in the window.
              `True` -&gt; Null values will be ignored.
              `False` -&gt; Any Null in the window leads to a Null in the aggregation result.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(
            self._s.rolling_max(window_size, weight, ignore_null, min_periods)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesrolling_mean"><a class="header" href="#polarseagerseriesseriesrolling_mean"><code>polars.eager.series.Series.rolling_mean</code></a></h3>
<pre><code class="language-python">rolling_mean(window_size: int, 
    weight: Optionaltp.List[float], 
    ignore_null: bool, 
    min_periods: Optionalint,) -&gt; Series:
</code></pre>
<p>Apply a rolling mean (moving mean) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weight</code>]: An optional slice with the same length of the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>ignore_null</code>]: Toggle behavior of aggregation regarding null values in the window.
<code>True</code> -&gt; Null values will be ignored.
<code>False</code> -&gt; Any Null in the window leads to a Null in the aggregation result.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_mean(
        self,
        window_size: int,
        weight: Optional[tp.List[float]] = None,
        ignore_null: bool = True,
        min_periods: Optional[int] = None,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a rolling mean (moving mean) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        window_size
            The length of the window.
        weight
            An optional slice with the same length of the window that will be multiplied
            elementwise with the values in the window.
        ignore_null
            Toggle behavior of aggregation regarding null values in the window.
              `True` -&gt; Null values will be ignored.
              `False` -&gt; Any Null in the window leads to a Null in the aggregation result.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(
            self._s.rolling_mean(window_size, weight, ignore_null, min_periods)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesrolling_sum"><a class="header" href="#polarseagerseriesseriesrolling_sum"><code>polars.eager.series.Series.rolling_sum</code></a></h3>
<pre><code class="language-python">rolling_sum(window_size: int, 
    weight: Optionaltp.List[float], 
    ignore_null: bool, 
    min_periods: Optionalint,) -&gt; Series:
</code></pre>
<p>Apply a rolling sum (moving sum) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weight</code>]: An optional slice with the same length of the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>ignore_null</code>]: Toggle behavior of aggregation regarding null values in the window.
<code>True</code> -&gt; Null values will be ignored.
<code>False</code> -&gt; Any Null in the window leads to a Null in the aggregation result.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_sum(
        self,
        window_size: int,
        weight: Optional[tp.List[float]] = None,
        ignore_null: bool = True,
        min_periods: Optional[int] = None,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a rolling sum (moving sum) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        window_size
            The length of the window.
        weight
            An optional slice with the same length of the window that will be multiplied
            elementwise with the values in the window.
        ignore_null
            Toggle behavior of aggregation regarding null values in the window.
              `True` -&gt; Null values will be ignored.
              `False` -&gt; Any Null in the window leads to a Null in the aggregation result.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(
            self._s.rolling_sum(window_size, weight, ignore_null, min_periods)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesparse_date"><a class="header" href="#polarseagerseriesseriesparse_date"><code>polars.eager.series.Series.parse_date</code></a></h3>
<pre><code class="language-python">parse_date(name: str, 
    values: Sequencestr, 
    dtype: TypeDataType, 
    fmt: str,) -&gt; Series:
</code></pre>
<p>.. deprecated::</p>
<p><strong>Decoration</strong> via <code>@staticmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def parse_date(
        name: str, values: Sequence[str], dtype: Type[DataType], fmt: str
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        .. deprecated::
        &quot;&quot;&quot;
        f = get_ffi_func(&quot;parse_&lt;&gt;_from_str_slice&quot;, dtype, PySeries)
        if f is None:
            return NotImplemented
        return wrap_s(f(name, values, fmt))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriessample"><a class="header" href="#polarseagerseriesseriessample"><code>polars.eager.series.Series.sample</code></a></h3>
<pre><code class="language-python">sample(n: Optionalint, 
    frac: Optionalfloat, 
    with_replacement: bool,) -&gt; Series:
</code></pre>
<p>Sample from this Series by setting either <code>n</code> or <code>frac</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n</code>]: Number of samples &lt; self.len().</li>
<li>[<code>frac</code>]: Fraction between 0.0 and 1.0 .</li>
<li>[<code>with_replacement</code>]: sample with replacement.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sample(
        self,
        n: Optional[int] = None,
        frac: Optional[float] = None,
        with_replacement: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Sample from this Series by setting either `n` or `frac`.

        Parameters
        ----------
        n
            Number of samples &lt; self.len().
        frac
            Fraction between 0.0 and 1.0 .
        with_replacement
            sample with replacement.
        &quot;&quot;&quot;
        if n is not None:
            return wrap_s(self._s.sample_n(n, with_replacement))
        return wrap_s(self._s.sample_frac(frac, with_replacement))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriespeak_max"><a class="header" href="#polarseagerseriesseriespeak_max"><code>polars.eager.series.Series.peak_max</code></a></h3>
<pre><code class="language-python">peak_max() -&gt; Series:
</code></pre>
<p>Get a boolean mask of the local maximum peaks.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def peak_max(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a boolean mask of the local maximum peaks.
        &quot;&quot;&quot;
        return wrap_s(self._s.peak_max())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriespeak_min"><a class="header" href="#polarseagerseriesseriespeak_min"><code>polars.eager.series.Series.peak_min</code></a></h3>
<pre><code class="language-python">peak_min() -&gt; Series:
</code></pre>
<p>Get a boolean mask of the local minimum peaks.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def peak_min(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a boolean mask of the local minimum peaks.
        &quot;&quot;&quot;
        return wrap_s(self._s.peak_min())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesn_unique"><a class="header" href="#polarseagerseriesseriesn_unique"><code>polars.eager.series.Series.n_unique</code></a></h3>
<pre><code class="language-python">n_unique() -&gt; int:
</code></pre>
<p>Count the number of unique values in this Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def n_unique(self) -&gt; int:
        &quot;&quot;&quot;
        Count the number of unique values in this Series.
        &quot;&quot;&quot;
        return self._s.n_unique()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesshrink_to_fit"><a class="header" href="#polarseagerseriesseriesshrink_to_fit"><code>polars.eager.series.Series.shrink_to_fit</code></a></h3>
<pre><code class="language-python">shrink_to_fit(in_place: bool) -&gt; OptionalSeries:
</code></pre>
<p>Shrink memory usage of this Series to fit the exact capacity needed to hold the data.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shrink_to_fit(self, in_place: bool = False) -&gt; Optional[&quot;Series&quot;]:
        &quot;&quot;&quot;
        Shrink memory usage of this Series to fit the exact capacity needed to hold the data.
        &quot;&quot;&quot;
        if in_place:
            self._s.shrink_to_fit()
            return None
        else:
            series = self.clone()
            series._s.shrink_to_fit()
            return series
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesdt"><a class="header" href="#polarseagerseriesseriesdt"><code>polars.eager.series.Series.dt</code></a></h3>
<pre><code class="language-python">dt() -&gt; DateTimeNameSpace:
</code></pre>
<p>Create an object namespace of all datetime related methods.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def dt(self) -&gt; &quot;DateTimeNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all datetime related methods.
        &quot;&quot;&quot;
        return DateTimeNameSpace(self)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesstr"><a class="header" href="#polarseagerseriesseriesstr"><code>polars.eager.series.Series.str</code></a></h3>
<pre><code class="language-python">str() -&gt; StringNameSpace:
</code></pre>
<p>Create an object namespace of all string related methods.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def str(self) -&gt; &quot;StringNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all string related methods.
        &quot;&quot;&quot;
        return StringNameSpace(self)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesserieshash"><a class="header" href="#polarseagerseriesserieshash"><code>polars.eager.series.Series.hash</code></a></h3>
<pre><code class="language-python">hash(k0: int, k1: int, k2: int, k3: int) -&gt; pl.Series:
</code></pre>
<p>Hash the Series.</p>
<p>The hash value is of type <code>UInt64</code></p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>k0</code>]: seed parameter</li>
<li>[<code>k1</code>]: seed parameter</li>
<li>[<code>k2</code>]: seed parameter</li>
<li>[<code>k3</code>]: seed parameter</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def hash(self, k0: int = 0, k1: int = 1, k2: int = 2, k3: int = 3) -&gt; &quot;pl.Series&quot;:
        &quot;&quot;&quot;
        Hash the Series.

        The hash value is of type `UInt64`

        Parameters
        ----------
        k0
            seed parameter
        k1
            seed parameter
        k2
            seed parameter
        k3
            seed parameter
        &quot;&quot;&quot;
        return wrap_s(self._s.hash(k0, k1, k2, k3))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarseagerseriesseriesreinterpret"><a class="header" href="#polarseagerseriesseriesreinterpret"><code>polars.eager.series.Series.reinterpret</code></a></h3>
<pre><code class="language-python">reinterpret(signed: bool) -&gt; Series:
</code></pre>
<p>Reinterpret the underlying bits as a signed/unsigned integer.
This operation is only allowed for 64bit integers. For lower bits integers,
you can safely use that cast operation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>signed</code>]: True -&gt; pl.Int64
False -&gt; pl.UInt64</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def reinterpret(self, signed: bool = True) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Reinterpret the underlying bits as a signed/unsigned integer.
        This operation is only allowed for 64bit integers. For lower bits integers,
        you can safely use that cast operation.

        Parameters
        ----------
        signed
            True -&gt; pl.Int64
            False -&gt; pl.UInt64
        &quot;&quot;&quot;
        return wrap_s(self._s.reinterpret(signed))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../../polars/eager/series.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../../polars/eager/series/StringNameSpace.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../../polars/eager/series.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../../polars/eager/series/StringNameSpace.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../../../theme/js/index.js"></script>
        

        

    </body>
</html>
