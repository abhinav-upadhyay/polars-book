<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Expr - Polars - Python Reference Guide</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../../favicon.png">
        
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        
        <link rel="stylesheet" href="../../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../../../theme/css/style.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../../../polars.html">polars</a></li><li class="chapter-item "><a href="../../../polars/datatypes.html">datatypes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/datatypes/DataType.html">DataType</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int8.html">Int8</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int16.html">Int16</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int32.html">Int32</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int64.html">Int64</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt8.html">UInt8</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt16.html">UInt16</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt32.html">UInt32</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt64.html">UInt64</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Float32.html">Float32</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Float64.html">Float64</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Boolean.html">Boolean</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Utf8.html">Utf8</a></li><li class="chapter-item "><a href="../../../polars/datatypes/List.html">List</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Date32.html">Date32</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Date64.html">Date64</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Time32Millisecond.html">Time32Millisecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Time32Second.html">Time32Second</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Time64Nanosecond.html">Time64Nanosecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Time64Microsecond.html">Time64Microsecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/DurationNanosecond.html">DurationNanosecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/DurationMicrosecond.html">DurationMicrosecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/DurationMillisecond.html">DurationMillisecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/DurationSecond.html">DurationSecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/TimestampNanosecond.html">TimestampNanosecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/TimestampMicrosecond.html">TimestampMicrosecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/TimestampMillisecond.html">TimestampMillisecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/TimestampSecond.html">TimestampSecond</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Object.html">Object</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Categorical.html">Categorical</a></li></ol></li><li class="chapter-item "><a href="../../../polars/eager.html">eager</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/eager/frame.html">frame</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/eager/frame/DataFrame.html">DataFrame</a></li><li class="chapter-item "><a href="../../../polars/eager/frame/GroupBy.html">GroupBy</a></li><li class="chapter-item "><a href="../../../polars/eager/frame/PivotOps.html">PivotOps</a></li><li class="chapter-item "><a href="../../../polars/eager/frame/GBSelection.html">GBSelection</a></li></ol></li><li class="chapter-item "><a href="../../../polars/eager/series.html">series</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/eager/series/Series.html">Series</a></li><li class="chapter-item "><a href="../../../polars/eager/series/StringNameSpace.html">StringNameSpace</a></li><li class="chapter-item "><a href="../../../polars/eager/series/DateTimeNameSpace.html">DateTimeNameSpace</a></li><li class="chapter-item "><a href="../../../polars/eager/series/SeriesIter.html">SeriesIter</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../../polars/functions.html">functions</a></li><li class="chapter-item "><a href="../../../polars/io.html">io</a></li><li class="chapter-item expanded "><a href="../../../polars/lazy.html">lazy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../polars/lazy/expr.html">expr</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../polars/lazy/expr/Expr.html" class="active">Expr</a></li><li class="chapter-item "><a href="../../../polars/lazy/expr/ExprStringNameSpace.html">ExprStringNameSpace</a></li><li class="chapter-item "><a href="../../../polars/lazy/expr/ExprDateTimeNameSpace.html">ExprDateTimeNameSpace</a></li></ol></li><li class="chapter-item "><a href="../../../polars/lazy/frame.html">frame</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/lazy/frame/LazyFrame.html">LazyFrame</a></li><li class="chapter-item "><a href="../../../polars/lazy/frame/LazyGroupBy.html">LazyGroupBy</a></li></ol></li><li class="chapter-item "><a href="../../../polars/lazy/functions.html">functions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/lazy/functions/UDF.html">UDF</a></li></ol></li><li class="chapter-item "><a href="../../../polars/lazy/whenthen.html">whenthen</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/lazy/whenthen/WhenThenThen.html">WhenThenThen</a></li><li class="chapter-item "><a href="../../../polars/lazy/whenthen/WhenThen.html">WhenThen</a></li><li class="chapter-item "><a href="../../../polars/lazy/whenthen/When.html">When</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../../polars/string_cache.html">string_cache</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/string_cache/StringCache.html">StringCache</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Polars - Python Reference Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="polarslazyexprexpr"><a class="header" href="#polarslazyexprexpr"><code>polars.lazy.expr.Expr</code></a></h1>
<p>Expressions that can be used in various contexts.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="#polarslazyexprexpreq"><code>eq()</code></a></li>
<li><a href="#polarslazyexprexprneq"><code>neq()</code></a></li>
<li><a href="#polarslazyexprexprgt"><code>gt()</code></a></li>
<li><a href="#polarslazyexprexprgt_eq"><code>gt_eq()</code></a></li>
<li><a href="#polarslazyexprexprlt_eq"><code>lt_eq()</code></a></li>
<li><a href="#polarslazyexprexprlt"><code>lt()</code></a></li>
<li><a href="#polarslazyexprexpralias"><code>alias()</code></a></li>
<li><a href="#polarslazyexprexpris_not"><code>is_not()</code></a></li>
<li><a href="#polarslazyexprexpris_null"><code>is_null()</code></a></li>
<li><a href="#polarslazyexprexpris_not_null"><code>is_not_null()</code></a></li>
<li><a href="#polarslazyexprexpris_finite"><code>is_finite()</code></a></li>
<li><a href="#polarslazyexprexpris_infinite"><code>is_infinite()</code></a></li>
<li><a href="#polarslazyexprexpris_nan"><code>is_nan()</code></a></li>
<li><a href="#polarslazyexprexpris_not_nan"><code>is_not_nan()</code></a></li>
<li><a href="#polarslazyexprexpragg_groups"><code>agg_groups()</code></a></li>
<li><a href="#polarslazyexprexprcount"><code>count()</code></a></li>
<li><a href="#polarslazyexprexprslice"><code>slice()</code></a></li>
<li><a href="#polarslazyexprexprcum_sum"><code>cum_sum()</code></a></li>
<li><a href="#polarslazyexprexprcum_min"><code>cum_min()</code></a></li>
<li><a href="#polarslazyexprexprcum_max"><code>cum_max()</code></a></li>
<li><a href="#polarslazyexprexprround"><code>round()</code></a></li>
<li><a href="#polarslazyexprexprdot"><code>dot()</code></a></li>
<li><a href="#polarslazyexprexprcast"><code>cast()</code></a></li>
<li><a href="#polarslazyexprexprsort"><code>sort()</code></a></li>
<li><a href="#polarslazyexprexprarg_sort"><code>arg_sort()</code></a></li>
<li><a href="#polarslazyexprexprsort_by"><code>sort_by()</code></a></li>
<li><a href="#polarslazyexprexprtake"><code>take()</code></a></li>
<li><a href="#polarslazyexprexprshift"><code>shift()</code></a></li>
<li><a href="#polarslazyexprexprshift_and_fill"><code>shift_and_fill()</code></a></li>
<li><a href="#polarslazyexprexprfill_none"><code>fill_none()</code></a></li>
<li><a href="#polarslazyexprexprforward_fill"><code>forward_fill()</code></a></li>
<li><a href="#polarslazyexprexprbackward_fill"><code>backward_fill()</code></a></li>
<li><a href="#polarslazyexprexprreverse"><code>reverse()</code></a></li>
<li><a href="#polarslazyexprexprstd"><code>std()</code></a></li>
<li><a href="#polarslazyexprexprvar"><code>var()</code></a></li>
<li><a href="#polarslazyexprexprmax"><code>max()</code></a></li>
<li><a href="#polarslazyexprexprmin"><code>min()</code></a></li>
<li><a href="#polarslazyexprexprsum"><code>sum()</code></a></li>
<li><a href="#polarslazyexprexprmean"><code>mean()</code></a></li>
<li><a href="#polarslazyexprexprmedian"><code>median()</code></a></li>
<li><a href="#polarslazyexprexprn_unique"><code>n_unique()</code></a></li>
<li><a href="#polarslazyexprexprarg_unique"><code>arg_unique()</code></a></li>
<li><a href="#polarslazyexprexprunique"><code>unique()</code></a></li>
<li><a href="#polarslazyexprexprfirst"><code>first()</code></a></li>
<li><a href="#polarslazyexprexprlast"><code>last()</code></a></li>
<li><a href="#polarslazyexprexprlist"><code>list()</code></a></li>
<li><a href="#polarslazyexprexprover"><code>over()</code></a></li>
<li><a href="#polarslazyexprexpris_unique"><code>is_unique()</code></a></li>
<li><a href="#polarslazyexprexpris_first"><code>is_first()</code></a></li>
<li><a href="#polarslazyexprexpris_duplicated"><code>is_duplicated()</code></a></li>
<li><a href="#polarslazyexprexprquantile"><code>quantile()</code></a></li>
<li><a href="#polarslazyexprexprfilter"><code>filter()</code></a></li>
<li><a href="#polarslazyexprexprmap"><code>map()</code></a></li>
<li><a href="#polarslazyexprexprapply"><code>apply()</code></a></li>
<li><a href="#polarslazyexprexprapplywrap_f"><code>wrap_f()</code></a></li>
<li><a href="#polarslazyexprexprexplode"><code>explode()</code></a></li>
<li><a href="#polarslazyexprexprtake_every"><code>take_every()</code></a></li>
<li><a href="#polarslazyexprexprhead"><code>head()</code></a></li>
<li><a href="#polarslazyexprexprtail"><code>tail()</code></a></li>
<li><a href="#polarslazyexprexprpow"><code>pow()</code></a></li>
<li><a href="#polarslazyexprexpris_in"><code>is_in()</code></a></li>
<li><a href="#polarslazyexprexprrepeat_by"><code>repeat_by()</code></a></li>
<li><a href="#polarslazyexprexpris_between"><code>is_between()</code></a></li>
<li><a href="#polarslazyexprexprdt"><code>dt()</code></a></li>
<li><a href="#polarslazyexprexprstr"><code>str()</code></a></li>
<li><a href="#polarslazyexprexprhash"><code>hash()</code></a></li>
<li><a href="#polarslazyexprexprreinterpret"><code>reinterpret()</code></a></li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Expr:
    &quot;&quot;&quot;
    Expressions that can be used in various contexts.
    &quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self._pyexpr: PyExpr

    @staticmethod
    def _from_pyexpr(pyexpr: &quot;PyExpr&quot;) -&gt; &quot;Expr&quot;:
        self = Expr.__new__(Expr)
        self._pyexpr = pyexpr
        return self

    def __to_pyexpr(self, other: Any) -&gt; &quot;PyExpr&quot;:
        if isinstance(other, PyExpr):
            return other
        elif isinstance(other, Expr):
            return other._pyexpr
        else:
            return lit(other)._pyexpr

    def __to_expr(self, other: Any) -&gt; &quot;Expr&quot;:
        if isinstance(other, Expr):
            return other
        return lit(other)

    def __invert__(self) -&gt; &quot;Expr&quot;:
        return self.is_not()

    def __and__(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr._and(other._pyexpr))

    def __or__(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr._or(other._pyexpr))

    def __add__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr + self.__to_pyexpr(other))

    def __sub__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr - self.__to_pyexpr(other))

    def __mul__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr * self.__to_pyexpr(other))

    def __truediv__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr / self.__to_pyexpr(other))

    def __pow__(self, power: float, modulo: None = None) -&gt; &quot;Expr&quot;:
        return self.pow(power)

    def __ge__(self, other: Any) -&gt; &quot;Expr&quot;:
        return self.gt_eq(self.__to_expr(other))

    def __le__(self, other: Any) -&gt; &quot;Expr&quot;:
        return self.lt_eq(self.__to_expr(other))

    def __eq__(self, other: Any) -&gt; &quot;Expr&quot;:  # type: ignore[override]
        return self.eq(self.__to_expr(other))

    def __ne__(self, other: Any) -&gt; &quot;Expr&quot;:  # type: ignore[override]
        return self.neq(self.__to_expr(other))

    def __lt__(self, other: Any) -&gt; &quot;Expr&quot;:
        return self.lt(self.__to_expr(other))

    def __gt__(self, other: Any) -&gt; &quot;Expr&quot;:
        return self.gt(self.__to_expr(other))

    def eq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.eq(other._pyexpr))

    def neq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.neq(other._pyexpr))

    def gt(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.gt(other._pyexpr))

    def gt_eq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.gt_eq(other._pyexpr))

    def lt_eq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.lt_eq(other._pyexpr))

    def lt(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.lt(other._pyexpr))

    def alias(self, name: str) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Rename the output of an expression.

        Parameters
        ----------
        name
            New name.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.alias(name))

    def is_not(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Negate a boolean expression.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_not())

    def is_null(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression contains null values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_null())

    def is_not_null(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression does not contain null values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_not_null())

    def is_finite(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are finite.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_finite())

    def is_infinite(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are infinite.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_infinite())

    def is_nan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are NaN (Not A Number).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_nan())

    def is_not_nan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are not NaN (Not A Number).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_not_nan())

    def agg_groups(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the group indexes of the group by operation.
        Should be used in aggregation context only.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.agg_groups())

    def count(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Count the number of values in this expression&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.count())

    def slice(self, offset: int, length: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Slice the Series.

        Parameters
        ----------
        offset
            Start index.
        length
            Length of the slice.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.slice(offset, length))

    def cum_sum(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative sum computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cum_sum(reverse))

    def cum_min(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative min computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cum_min(reverse))

    def cum_max(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative max computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cum_max(reverse))

    def round(self, decimals: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Round underlying floating point data by `decimals` digits.

        Parameters
        ----------
        decimals
            Number of decimals to round by.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.round(decimals))

    def dot(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the dot/inner product between two Expressions

        Parameters
        ----------
        other
            Expression to compute dot product with
        &quot;&quot;&quot;
        other = expr_to_lit_or_expr(other, str_to_lit=False)
        return wrap_expr(self._pyexpr.dot(other._pyexpr))

    def cast(self, dtype: Type[Any]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Cast an expression to a different data types.

        Parameters
        ----------
        dtype
            Output data type.
        &quot;&quot;&quot;
        if dtype == str:
            dtype = Utf8
        elif dtype == bool:
            dtype = Boolean
        elif dtype == float:
            dtype = Float64
        elif dtype == int:
            dtype = Int64
        return wrap_expr(self._pyexpr.cast(dtype))

    def sort(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Sort this column. In projection/ selection context the whole column is sorted.
        If used in a groupby context, the groups are sorted.

        Parameters
        ----------
        reverse
            False -&gt; order from small to large.
            True -&gt; order from large to small.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.sort(reverse))

    def arg_sort(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the index values that would sort this column.

        Parameters
        ----------
        reverse
            False -&gt; order from small to large.
            True -&gt; order from large to small.

        Returns
        -------
        out
            Series of type UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_sort(reverse))

    def sort_by(self, by: Union[&quot;Expr&quot;, str], reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Sort this column by the ordering of another column.
        In projection/ selection context the whole column is sorted.
        If used in a groupby context, the groups are sorted.

        Parameters
        ----------
        by
            The column used for sorting.
        reverse
            False -&gt; order from small to large.
            True -&gt; order from large to small.
        &quot;&quot;&quot;
        if isinstance(by, str):
            by = col(by)

        return wrap_expr(self._pyexpr.sort_by(by._pyexpr, reverse))

    def take(self, index: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take values by index.

        Parameters
        ----------
        index
            An expression that leads to a UInt32 dtyped Series.

        Returns
        -------
        Values taken by index
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.take(index._pyexpr))

    def shift(self, periods: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with `Nones`.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.shift(periods))

    def shift_and_fill(self, periods: int, fill_value: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with the result of the `fill_value` expression.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        fill_value
            Fill None values with the result of this expression.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.shift_and_fill(periods, fill_value._pyexpr))

    def fill_none(self, fill_value: Union[str, int, float, &quot;Expr&quot;]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill none value with a fill value
        &quot;&quot;&quot;
        if not isinstance(fill_value, Expr):
            fill_value = lit(fill_value)
        return wrap_expr(self._pyexpr.fill_none(fill_value._pyexpr))

    def forward_fill(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill missing values with the latest seen values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.forward_fill())

    def backward_fill(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill missing values with the next to be seen values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.backward_fill())

    def reverse(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Reverse the selection.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.reverse())

    def std(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get standard deviation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.std())

    def var(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get variance.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.var())

    def max(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get maximum value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.max())

    def min(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get minimum value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.min())

    def sum(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get sum value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.sum())

    def mean(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get mean value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.mean())

    def median(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get median value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.median())

    def n_unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Count unique values.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.n_unique())

    def arg_unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Get index of first unique value.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_unique())

    def unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Get unique values.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.unique())

    def first(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the first value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.first())

    def last(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the last value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.last())

    def list(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Aggregate to list.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.list())

    def over(self, expr: Union[str, &quot;Expr&quot;, tp.List[&quot;Expr&quot;]]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply window function over a subgroup.
        This is similar to a groupby + aggregation + self join.
        Or similar to [window functions in Postgres](https://www.postgresql.org/docs/9.1/tutorial-window.html)

        Parameters
        ----------
        expr
            Column(s) to group by.

        Examples
        --------

        ``` python
        df = DataFrame({
            &quot;groups&quot;: [1, 1, 2, 2, 1, 2, 3, 3, 1],
            &quot;values&quot;: [1, 2, 3, 4, 5, 6, 7, 8, 8]
        })
        print(df.lazy()
            .select([
                col(&quot;groups&quot;)
                sum(&quot;values&quot;).over(&quot;groups&quot;))
            ]).collect())

        ```

        outputs:

        ``` text
            ╭────────┬────────╮
            │ groups ┆ values │
            │ ---    ┆ ---    │
            │ i32    ┆ i32    │
            ╞════════╪════════╡
            │ 1      ┆ 16     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 1      ┆ 16     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 2      ┆ 13     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 2      ┆ 13     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ ...    ┆ ...    │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 1      ┆ 16     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 2      ┆ 13     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 3      ┆ 15     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 3      ┆ 15     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 1      ┆ 16     │
            ╰────────┴────────╯

        ```
        &quot;&quot;&quot;

        pyexprs = _selection_to_pyexpr_list(expr)

        return wrap_expr(self._pyexpr.over(pyexprs))

    def is_unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get mask of unique values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_unique())

    def is_first(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get a mask of the first unique value.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_first())

    def is_duplicated(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get mask of duplicated values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_duplicated())

    def quantile(self, quantile: float) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get quantile value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.quantile(quantile))

    def filter(self, predicate: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Filter a single column.
        Should be used in aggregation context. If you want to filter on a DataFrame level, use `LazyFrame.filter`.

        Parameters
        ----------
        predicate
            Boolean expression.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.filter(predicate._pyexpr))

    def map(
        self,
        f: Union[&quot;UDF&quot;, Callable[[&quot;pl.Series&quot;], &quot;pl.Series&quot;]],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a custom UDF. It is important that the UDF returns a Polars Series.

        [read more in the book](https://ritchie46.github.io/polars-book/how_can_i/use_custom_functions.html#lazy)

        Parameters
        ----------
        f
            Lambda/ function to apply.
        return_dtype
            Dtype of the output Series.
        &quot;&quot;&quot;
        if isinstance(f, UDF):
            return_dtype = f.return_dtype
            f = f.f
        if return_dtype == str:
            return_dtype = Utf8
        elif return_dtype == int:
            return_dtype = Int64
        elif return_dtype == float:
            return_dtype = Float64
        elif return_dtype == bool:
            return_dtype = Boolean
        return wrap_expr(self._pyexpr.map(f, return_dtype))

    def apply(
        self,
        f: Callable[[&quot;pl.Series&quot;], &quot;pl.Series&quot;],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a custom UDF in a GroupBy context. This is syntactic sugar for the `apply` method which operates on all
        groups at once. The UDF passed to this expression will operate on a single group.

        Parameters
        ----------
        f
            Lambda/ function to apply.
        return_dtype
            Dtype of the output Series.

        # Example

        ```python
        df = pl.DataFrame({&quot;a&quot;: [1,  2,  1,  1],
                   &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;]})

        (df
         .lazy()
         .groupby(&quot;b&quot;)
         .agg([col(&quot;a&quot;).apply(lambda x: x.sum())])
         .collect()
        )
        ```

        &gt; returns

        ```text
        shape: (3, 2)
        ╭─────┬─────╮
        │ b   ┆ a   │
        │ --- ┆ --- │
        │ str ┆ i64 │
        ╞═════╪═════╡
        │ a   ┆ 1   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ b   ┆ 2   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ c   ┆ 2   │
        ╰─────┴─────╯
        ```
        &quot;&quot;&quot;

        # input x: Series of type list containing the group values
        def wrap_f(x: &quot;pl.Series&quot;) -&gt; &quot;pl.Series&quot;:
            return x.apply(f, return_dtype=return_dtype)

        return self.map(wrap_f)

    def explode(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Explode a list or utf8 Series. This means that every item is expanded to a new row.

        Returns
        -------
        Exploded Series of same dtype
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.explode())

    def take_every(self, n: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take every nth value in the Series and return as a new Series.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.take_every(n))

    def head(self, n: Optional[int] = None) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take the first n values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.head(n))

    def tail(self, n: Optional[int] = None) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take the last n values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.tail(n))

    def pow(self, exponent: float) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Raise expression to the power of exponent.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.pow(exponent))

    def is_in(self, other: Union[&quot;Expr&quot;, tp.List[Any]]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Check if elements of this Series are in the right Series, or List values of the right Series.

        Parameters
        ----------
        other
            Series of primitive type or List type.

        Returns
        -------
        Expr that evaluates to a Boolean Series.
        &quot;&quot;&quot;
        if isinstance(other, list):
            other = lit(pl.Series(&quot;&quot;, other))
        return wrap_expr(self._pyexpr.is_in(other._pyexpr))

    def repeat_by(self, by: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Repeat the elements in this Series `n` times by dictated by the number given by `by`.
        The elements are expanded into a `List`

        Parameters
        ----------
        by
            Numeric column that determines how often the values will be repeated.
            The column will be coerced to UInt32. Give this dtype to make the coercion a no-op.

        Returns
        -------
        Series of type List
        &quot;&quot;&quot;
        by = expr_to_lit_or_expr(by, False)
        return wrap_expr(self._pyexpr.repeat_by(by._pyexpr))

    def is_between(
        self, start: Union[&quot;Expr&quot;, datetime], end: Union[&quot;Expr&quot;, datetime]
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Check if this expression is between start and end.
        &quot;&quot;&quot;
        cast_to_date64 = False
        if isinstance(start, datetime):
            start = lit(start)
            cast_to_date64 = True
        if isinstance(end, datetime):
            end = lit(end)
            cast_to_date64 = True
        if cast_to_date64:
            expr = self.cast(Date64)
        else:
            expr = self
        return ((expr &gt; start) &amp; (expr &lt; end)).alias(&quot;is_between&quot;)

    @property
    def dt(self) -&gt; &quot;ExprDateTimeNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all datetime related methods.
        &quot;&quot;&quot;
        return ExprDateTimeNameSpace(self)

    @property
    def str(self) -&gt; &quot;ExprStringNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all string related methods.
        &quot;&quot;&quot;
        return ExprStringNameSpace(self)

    def hash(self, k0: int = 0, k1: int = 1, k2: int = 2, k3: int = 3) -&gt; &quot;pl.Expr&quot;:
        &quot;&quot;&quot;
        Hash the Series.

        The hash value is of type `Date64`

        Parameters
        ----------
        k0
            seed parameter
        k1
            seed parameter
        k2
            seed parameter
        k3
            seed parameter
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.hash(k0, k1, k2, k3))

    def reinterpret(self, signed: bool) -&gt; &quot;pl.Expr&quot;:
        &quot;&quot;&quot;
        Reinterpret the underlying bits as a signed/unsigned integer.
        This operation is only allowed for 64bit integers. For lower bits integers,
        you can safely use that cast operation.

        Parameters
        ----------
        signed
            True -&gt; pl.Int64
            False -&gt; pl.UInt64
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.reinterpret(signed))
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<pre><code class="language-python">Expr()
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(self) -&gt; None:
        self._pyexpr: PyExpr
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexpreq"><a class="header" href="#polarslazyexprexpreq"><code>polars.lazy.expr.Expr.eq</code></a></h3>
<pre><code class="language-python">eq(other: Expr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def eq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.eq(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprneq"><a class="header" href="#polarslazyexprexprneq"><code>polars.lazy.expr.Expr.neq</code></a></h3>
<pre><code class="language-python">neq(other: Expr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def neq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.neq(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprgt"><a class="header" href="#polarslazyexprexprgt"><code>polars.lazy.expr.Expr.gt</code></a></h3>
<pre><code class="language-python">gt(other: Expr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def gt(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.gt(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprgt_eq"><a class="header" href="#polarslazyexprexprgt_eq"><code>polars.lazy.expr.Expr.gt_eq</code></a></h3>
<pre><code class="language-python">gt_eq(other: Expr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def gt_eq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.gt_eq(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprlt_eq"><a class="header" href="#polarslazyexprexprlt_eq"><code>polars.lazy.expr.Expr.lt_eq</code></a></h3>
<pre><code class="language-python">lt_eq(other: Expr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def lt_eq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.lt_eq(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprlt"><a class="header" href="#polarslazyexprexprlt"><code>polars.lazy.expr.Expr.lt</code></a></h3>
<pre><code class="language-python">lt(other: Expr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def lt(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.lt(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexpralias"><a class="header" href="#polarslazyexprexpralias"><code>polars.lazy.expr.Expr.alias</code></a></h3>
<pre><code class="language-python">alias(name: str) -&gt; Expr:
</code></pre>
<p>Rename the output of an expression.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: New name.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def alias(self, name: str) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Rename the output of an expression.

        Parameters
        ----------
        name
            New name.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.alias(name))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexpris_not"><a class="header" href="#polarslazyexprexpris_not"><code>polars.lazy.expr.Expr.is_not</code></a></h3>
<pre><code class="language-python">is_not() -&gt; Expr:
</code></pre>
<p>Negate a boolean expression.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_not(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Negate a boolean expression.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_not())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexpris_null"><a class="header" href="#polarslazyexprexpris_null"><code>polars.lazy.expr.Expr.is_null</code></a></h3>
<pre><code class="language-python">is_null() -&gt; Expr:
</code></pre>
<p>Create a boolean expression returning <code>True</code> where the expression contains null values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_null(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression contains null values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_null())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexpris_not_null"><a class="header" href="#polarslazyexprexpris_not_null"><code>polars.lazy.expr.Expr.is_not_null</code></a></h3>
<pre><code class="language-python">is_not_null() -&gt; Expr:
</code></pre>
<p>Create a boolean expression returning <code>True</code> where the expression does not contain null values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_not_null(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression does not contain null values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_not_null())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexpris_finite"><a class="header" href="#polarslazyexprexpris_finite"><code>polars.lazy.expr.Expr.is_finite</code></a></h3>
<pre><code class="language-python">is_finite() -&gt; Expr:
</code></pre>
<p>Create a boolean expression returning <code>True</code> where the expression values are finite.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_finite(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are finite.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_finite())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexpris_infinite"><a class="header" href="#polarslazyexprexpris_infinite"><code>polars.lazy.expr.Expr.is_infinite</code></a></h3>
<pre><code class="language-python">is_infinite() -&gt; Expr:
</code></pre>
<p>Create a boolean expression returning <code>True</code> where the expression values are infinite.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_infinite(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are infinite.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_infinite())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexpris_nan"><a class="header" href="#polarslazyexprexpris_nan"><code>polars.lazy.expr.Expr.is_nan</code></a></h3>
<pre><code class="language-python">is_nan() -&gt; Expr:
</code></pre>
<p>Create a boolean expression returning <code>True</code> where the expression values are NaN (Not A Number).</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_nan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are NaN (Not A Number).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_nan())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexpris_not_nan"><a class="header" href="#polarslazyexprexpris_not_nan"><code>polars.lazy.expr.Expr.is_not_nan</code></a></h3>
<pre><code class="language-python">is_not_nan() -&gt; Expr:
</code></pre>
<p>Create a boolean expression returning <code>True</code> where the expression values are not NaN (Not A Number).</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_not_nan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are not NaN (Not A Number).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_not_nan())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexpragg_groups"><a class="header" href="#polarslazyexprexpragg_groups"><code>polars.lazy.expr.Expr.agg_groups</code></a></h3>
<pre><code class="language-python">agg_groups() -&gt; Expr:
</code></pre>
<p>Get the group indexes of the group by operation.
Should be used in aggregation context only.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def agg_groups(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the group indexes of the group by operation.
        Should be used in aggregation context only.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.agg_groups())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprcount"><a class="header" href="#polarslazyexprexprcount"><code>polars.lazy.expr.Expr.count</code></a></h3>
<pre><code class="language-python">count() -&gt; Expr:
</code></pre>
<p>Count the number of values in this expression</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def count(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Count the number of values in this expression&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.count())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprslice"><a class="header" href="#polarslazyexprexprslice"><code>polars.lazy.expr.Expr.slice</code></a></h3>
<pre><code class="language-python">slice(offset: int, length: int) -&gt; Expr:
</code></pre>
<p>Slice the Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>offset</code>]: Start index.</li>
<li>[<code>length</code>]: Length of the slice.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def slice(self, offset: int, length: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Slice the Series.

        Parameters
        ----------
        offset
            Start index.
        length
            Length of the slice.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.slice(offset, length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprcum_sum"><a class="header" href="#polarslazyexprexprcum_sum"><code>polars.lazy.expr.Expr.cum_sum</code></a></h3>
<pre><code class="language-python">cum_sum(reverse: bool) -&gt; Expr:
</code></pre>
<p>Get an array with the cumulative sum computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: Reverse the operation.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cum_sum(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative sum computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cum_sum(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprcum_min"><a class="header" href="#polarslazyexprexprcum_min"><code>polars.lazy.expr.Expr.cum_min</code></a></h3>
<pre><code class="language-python">cum_min(reverse: bool) -&gt; Expr:
</code></pre>
<p>Get an array with the cumulative min computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: Reverse the operation.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cum_min(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative min computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cum_min(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprcum_max"><a class="header" href="#polarslazyexprexprcum_max"><code>polars.lazy.expr.Expr.cum_max</code></a></h3>
<pre><code class="language-python">cum_max(reverse: bool) -&gt; Expr:
</code></pre>
<p>Get an array with the cumulative max computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: Reverse the operation.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cum_max(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative max computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cum_max(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprround"><a class="header" href="#polarslazyexprexprround"><code>polars.lazy.expr.Expr.round</code></a></h3>
<pre><code class="language-python">round(decimals: int) -&gt; Expr:
</code></pre>
<p>Round underlying floating point data by <code>decimals</code> digits.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>decimals</code>]: Number of decimals to round by.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def round(self, decimals: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Round underlying floating point data by `decimals` digits.

        Parameters
        ----------
        decimals
            Number of decimals to round by.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.round(decimals))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprdot"><a class="header" href="#polarslazyexprexprdot"><code>polars.lazy.expr.Expr.dot</code></a></h3>
<pre><code class="language-python">dot(other: Expr) -&gt; Expr:
</code></pre>
<p>Compute the dot/inner product between two Expressions</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: Expression to compute dot product with</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def dot(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the dot/inner product between two Expressions

        Parameters
        ----------
        other
            Expression to compute dot product with
        &quot;&quot;&quot;
        other = expr_to_lit_or_expr(other, str_to_lit=False)
        return wrap_expr(self._pyexpr.dot(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprcast"><a class="header" href="#polarslazyexprexprcast"><code>polars.lazy.expr.Expr.cast</code></a></h3>
<pre><code class="language-python">cast(dtype: TypeAny) -&gt; Expr:
</code></pre>
<p>Cast an expression to a different data types.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>dtype</code>]: Output data type.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cast(self, dtype: Type[Any]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Cast an expression to a different data types.

        Parameters
        ----------
        dtype
            Output data type.
        &quot;&quot;&quot;
        if dtype == str:
            dtype = Utf8
        elif dtype == bool:
            dtype = Boolean
        elif dtype == float:
            dtype = Float64
        elif dtype == int:
            dtype = Int64
        return wrap_expr(self._pyexpr.cast(dtype))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprsort"><a class="header" href="#polarslazyexprexprsort"><code>polars.lazy.expr.Expr.sort</code></a></h3>
<pre><code class="language-python">sort(reverse: bool) -&gt; Expr:
</code></pre>
<p>Sort this column. In projection/ selection context the whole column is sorted.
If used in a groupby context, the groups are sorted.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: False -&gt; order from small to large.
True -&gt; order from large to small.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sort(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Sort this column. In projection/ selection context the whole column is sorted.
        If used in a groupby context, the groups are sorted.

        Parameters
        ----------
        reverse
            False -&gt; order from small to large.
            True -&gt; order from large to small.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.sort(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprarg_sort"><a class="header" href="#polarslazyexprexprarg_sort"><code>polars.lazy.expr.Expr.arg_sort</code></a></h3>
<pre><code class="language-python">arg_sort(reverse: bool) -&gt; Expr:
</code></pre>
<p>Get the index values that would sort this column.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: False -&gt; order from small to large.
True -&gt; order from large to small.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li>[<code>out</code>]: Series of type UInt32</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_sort(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the index values that would sort this column.

        Parameters
        ----------
        reverse
            False -&gt; order from small to large.
            True -&gt; order from large to small.

        Returns
        -------
        out
            Series of type UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_sort(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprsort_by"><a class="header" href="#polarslazyexprexprsort_by"><code>polars.lazy.expr.Expr.sort_by</code></a></h3>
<pre><code class="language-python">sort_by(by: Union[Expr, str], reverse: bool) -&gt; Expr:
</code></pre>
<p>Sort this column by the ordering of another column.
In projection/ selection context the whole column is sorted.
If used in a groupby context, the groups are sorted.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>by</code>]: The column used for sorting.</li>
<li>[<code>reverse</code>]: False -&gt; order from small to large.
True -&gt; order from large to small.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sort_by(self, by: Union[&quot;Expr&quot;, str], reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Sort this column by the ordering of another column.
        In projection/ selection context the whole column is sorted.
        If used in a groupby context, the groups are sorted.

        Parameters
        ----------
        by
            The column used for sorting.
        reverse
            False -&gt; order from small to large.
            True -&gt; order from large to small.
        &quot;&quot;&quot;
        if isinstance(by, str):
            by = col(by)

        return wrap_expr(self._pyexpr.sort_by(by._pyexpr, reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprtake"><a class="header" href="#polarslazyexprexprtake"><code>polars.lazy.expr.Expr.take</code></a></h3>
<pre><code class="language-python">take(index: Expr) -&gt; Expr:
</code></pre>
<p>Take values by index.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>index</code>]: An expression that leads to a UInt32 dtyped Series.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Values taken by index</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def take(self, index: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take values by index.

        Parameters
        ----------
        index
            An expression that leads to a UInt32 dtyped Series.

        Returns
        -------
        Values taken by index
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.take(index._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprshift"><a class="header" href="#polarslazyexprexprshift"><code>polars.lazy.expr.Expr.shift</code></a></h3>
<pre><code class="language-python">shift(periods: int) -&gt; Expr:
</code></pre>
<p>Shift the values by a given period and fill the parts that will be empty due to this operation
with <code>Nones</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>periods</code>]: Number of places to shift (may be negative).</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shift(self, periods: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with `Nones`.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.shift(periods))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprshift_and_fill"><a class="header" href="#polarslazyexprexprshift_and_fill"><code>polars.lazy.expr.Expr.shift_and_fill</code></a></h3>
<pre><code class="language-python">shift_and_fill(periods: int, fill_value: Expr) -&gt; Expr:
</code></pre>
<p>Shift the values by a given period and fill the parts that will be empty due to this operation
with the result of the <code>fill_value</code> expression.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>periods</code>]: Number of places to shift (may be negative).</li>
<li>[<code>fill_value</code>]: Fill None values with the result of this expression.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shift_and_fill(self, periods: int, fill_value: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with the result of the `fill_value` expression.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        fill_value
            Fill None values with the result of this expression.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.shift_and_fill(periods, fill_value._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprfill_none"><a class="header" href="#polarslazyexprexprfill_none"><code>polars.lazy.expr.Expr.fill_none</code></a></h3>
<pre><code class="language-python">fill_none(fill_value: Union[str, int, float, Expr],) -&gt; Expr:
</code></pre>
<p>Fill none value with a fill value</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def fill_none(self, fill_value: Union[str, int, float, &quot;Expr&quot;]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill none value with a fill value
        &quot;&quot;&quot;
        if not isinstance(fill_value, Expr):
            fill_value = lit(fill_value)
        return wrap_expr(self._pyexpr.fill_none(fill_value._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprforward_fill"><a class="header" href="#polarslazyexprexprforward_fill"><code>polars.lazy.expr.Expr.forward_fill</code></a></h3>
<pre><code class="language-python">forward_fill() -&gt; Expr:
</code></pre>
<p>Fill missing values with the latest seen values</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def forward_fill(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill missing values with the latest seen values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.forward_fill())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprbackward_fill"><a class="header" href="#polarslazyexprexprbackward_fill"><code>polars.lazy.expr.Expr.backward_fill</code></a></h3>
<pre><code class="language-python">backward_fill() -&gt; Expr:
</code></pre>
<p>Fill missing values with the next to be seen values</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def backward_fill(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill missing values with the next to be seen values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.backward_fill())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprreverse"><a class="header" href="#polarslazyexprexprreverse"><code>polars.lazy.expr.Expr.reverse</code></a></h3>
<pre><code class="language-python">reverse() -&gt; Expr:
</code></pre>
<p>Reverse the selection.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def reverse(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Reverse the selection.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.reverse())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprstd"><a class="header" href="#polarslazyexprexprstd"><code>polars.lazy.expr.Expr.std</code></a></h3>
<pre><code class="language-python">std() -&gt; Expr:
</code></pre>
<p>Get standard deviation.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def std(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get standard deviation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.std())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprvar"><a class="header" href="#polarslazyexprexprvar"><code>polars.lazy.expr.Expr.var</code></a></h3>
<pre><code class="language-python">var() -&gt; Expr:
</code></pre>
<p>Get variance.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def var(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get variance.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.var())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprmax"><a class="header" href="#polarslazyexprexprmax"><code>polars.lazy.expr.Expr.max</code></a></h3>
<pre><code class="language-python">max() -&gt; Expr:
</code></pre>
<p>Get maximum value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def max(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get maximum value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.max())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprmin"><a class="header" href="#polarslazyexprexprmin"><code>polars.lazy.expr.Expr.min</code></a></h3>
<pre><code class="language-python">min() -&gt; Expr:
</code></pre>
<p>Get minimum value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def min(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get minimum value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.min())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprsum"><a class="header" href="#polarslazyexprexprsum"><code>polars.lazy.expr.Expr.sum</code></a></h3>
<pre><code class="language-python">sum() -&gt; Expr:
</code></pre>
<p>Get sum value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sum(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get sum value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.sum())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprmean"><a class="header" href="#polarslazyexprexprmean"><code>polars.lazy.expr.Expr.mean</code></a></h3>
<pre><code class="language-python">mean() -&gt; Expr:
</code></pre>
<p>Get mean value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mean(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get mean value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.mean())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprmedian"><a class="header" href="#polarslazyexprexprmedian"><code>polars.lazy.expr.Expr.median</code></a></h3>
<pre><code class="language-python">median() -&gt; Expr:
</code></pre>
<p>Get median value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def median(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get median value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.median())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprn_unique"><a class="header" href="#polarslazyexprexprn_unique"><code>polars.lazy.expr.Expr.n_unique</code></a></h3>
<pre><code class="language-python">n_unique() -&gt; Expr:
</code></pre>
<p>Count unique values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def n_unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Count unique values.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.n_unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprarg_unique"><a class="header" href="#polarslazyexprexprarg_unique"><code>polars.lazy.expr.Expr.arg_unique</code></a></h3>
<pre><code class="language-python">arg_unique() -&gt; Expr:
</code></pre>
<p>Get index of first unique value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Get index of first unique value.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprunique"><a class="header" href="#polarslazyexprexprunique"><code>polars.lazy.expr.Expr.unique</code></a></h3>
<pre><code class="language-python">unique() -&gt; Expr:
</code></pre>
<p>Get unique values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Get unique values.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprfirst"><a class="header" href="#polarslazyexprexprfirst"><code>polars.lazy.expr.Expr.first</code></a></h3>
<pre><code class="language-python">first() -&gt; Expr:
</code></pre>
<p>Get the first value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def first(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the first value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.first())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprlast"><a class="header" href="#polarslazyexprexprlast"><code>polars.lazy.expr.Expr.last</code></a></h3>
<pre><code class="language-python">last() -&gt; Expr:
</code></pre>
<p>Get the last value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def last(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the last value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.last())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprlist"><a class="header" href="#polarslazyexprexprlist"><code>polars.lazy.expr.Expr.list</code></a></h3>
<pre><code class="language-python">list() -&gt; Expr:
</code></pre>
<p>Aggregate to list.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def list(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Aggregate to list.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.list())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprover"><a class="header" href="#polarslazyexprexprover"><code>polars.lazy.expr.Expr.over</code></a></h3>
<pre><code class="language-python">over(expr: Union[str, Expr, tp.List[Expr]]) -&gt; Expr:
</code></pre>
<p>Apply window function over a subgroup.
This is similar to a groupby + aggregation + self join.
Or similar to <a href="https:/www.postgresql.org/docs/9.1/tutorial-window.html">window functions in Postgres</a></p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>expr</code>]: Column(s) to group by.</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-python">df = DataFrame({
    &quot;groups&quot;: [1, 1, 2, 2, 1, 2, 3, 3, 1],
    &quot;values&quot;: [1, 2, 3, 4, 5, 6, 7, 8, 8]
})
print(df.lazy()
    .select([
        col(&quot;groups&quot;)
        sum(&quot;values&quot;).over(&quot;groups&quot;))
    ]).collect())

</code></pre>
<p>outputs:</p>
<pre><code class="language-text">    ╭────────┬────────╮
    │ groups ┆ values │
    │ ---    ┆ ---    │
    │ i32    ┆ i32    │
    ╞════════╪════════╡
    │ 1      ┆ 16     │
    ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
    │ 1      ┆ 16     │
    ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
    │ 2      ┆ 13     │
    ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
    │ 2      ┆ 13     │
    ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
    │ ...    ┆ ...    │
    ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
    │ 1      ┆ 16     │
    ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
    │ 2      ┆ 13     │
    ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
    │ 3      ┆ 15     │
    ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
    │ 3      ┆ 15     │
    ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
    │ 1      ┆ 16     │
    ╰────────┴────────╯

</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def over(self, expr: Union[str, &quot;Expr&quot;, tp.List[&quot;Expr&quot;]]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply window function over a subgroup.
        This is similar to a groupby + aggregation + self join.
        Or similar to [window functions in Postgres](https://www.postgresql.org/docs/9.1/tutorial-window.html)

        Parameters
        ----------
        expr
            Column(s) to group by.

        Examples
        --------

        ``` python
        df = DataFrame({
            &quot;groups&quot;: [1, 1, 2, 2, 1, 2, 3, 3, 1],
            &quot;values&quot;: [1, 2, 3, 4, 5, 6, 7, 8, 8]
        })
        print(df.lazy()
            .select([
                col(&quot;groups&quot;)
                sum(&quot;values&quot;).over(&quot;groups&quot;))
            ]).collect())

        ```

        outputs:

        ``` text
            ╭────────┬────────╮
            │ groups ┆ values │
            │ ---    ┆ ---    │
            │ i32    ┆ i32    │
            ╞════════╪════════╡
            │ 1      ┆ 16     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 1      ┆ 16     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 2      ┆ 13     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 2      ┆ 13     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ ...    ┆ ...    │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 1      ┆ 16     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 2      ┆ 13     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 3      ┆ 15     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 3      ┆ 15     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 1      ┆ 16     │
            ╰────────┴────────╯

        ```
        &quot;&quot;&quot;

        pyexprs = _selection_to_pyexpr_list(expr)

        return wrap_expr(self._pyexpr.over(pyexprs))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexpris_unique"><a class="header" href="#polarslazyexprexpris_unique"><code>polars.lazy.expr.Expr.is_unique</code></a></h3>
<pre><code class="language-python">is_unique() -&gt; Expr:
</code></pre>
<p>Get mask of unique values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get mask of unique values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexpris_first"><a class="header" href="#polarslazyexprexpris_first"><code>polars.lazy.expr.Expr.is_first</code></a></h3>
<pre><code class="language-python">is_first() -&gt; Expr:
</code></pre>
<p>Get a mask of the first unique value.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_first(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get a mask of the first unique value.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_first())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexpris_duplicated"><a class="header" href="#polarslazyexprexpris_duplicated"><code>polars.lazy.expr.Expr.is_duplicated</code></a></h3>
<pre><code class="language-python">is_duplicated() -&gt; Expr:
</code></pre>
<p>Get mask of duplicated values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_duplicated(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get mask of duplicated values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_duplicated())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprquantile"><a class="header" href="#polarslazyexprexprquantile"><code>polars.lazy.expr.Expr.quantile</code></a></h3>
<pre><code class="language-python">quantile(quantile: float) -&gt; Expr:
</code></pre>
<p>Get quantile value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def quantile(self, quantile: float) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get quantile value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.quantile(quantile))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprfilter"><a class="header" href="#polarslazyexprexprfilter"><code>polars.lazy.expr.Expr.filter</code></a></h3>
<pre><code class="language-python">filter(predicate: Expr) -&gt; Expr:
</code></pre>
<p>Filter a single column.
Should be used in aggregation context. If you want to filter on a DataFrame level, use <code>LazyFrame.filter</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>predicate</code>]: Boolean expression.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def filter(self, predicate: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Filter a single column.
        Should be used in aggregation context. If you want to filter on a DataFrame level, use `LazyFrame.filter`.

        Parameters
        ----------
        predicate
            Boolean expression.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.filter(predicate._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprmap"><a class="header" href="#polarslazyexprexprmap"><code>polars.lazy.expr.Expr.map</code></a></h3>
<pre><code class="language-python">map(f: Union[UDF, Callable[[pl.Series], pl.Series]], 
    return_dtype: OptionalTypeDataType,) -&gt; Expr:
</code></pre>
<p>Apply a custom UDF. It is important that the UDF returns a Polars Series.</p>
<p><a href="https:/ritchie46.github.io/polars-book/how_can_i/use_custom_functions.html#lazy">read more in the book</a></p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>f</code>]: Lambda/ function to apply.</li>
<li>[<code>return_dtype</code>]: Dtype of the output Series.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def map(
        self,
        f: Union[&quot;UDF&quot;, Callable[[&quot;pl.Series&quot;], &quot;pl.Series&quot;]],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a custom UDF. It is important that the UDF returns a Polars Series.

        [read more in the book](https://ritchie46.github.io/polars-book/how_can_i/use_custom_functions.html#lazy)

        Parameters
        ----------
        f
            Lambda/ function to apply.
        return_dtype
            Dtype of the output Series.
        &quot;&quot;&quot;
        if isinstance(f, UDF):
            return_dtype = f.return_dtype
            f = f.f
        if return_dtype == str:
            return_dtype = Utf8
        elif return_dtype == int:
            return_dtype = Int64
        elif return_dtype == float:
            return_dtype = Float64
        elif return_dtype == bool:
            return_dtype = Boolean
        return wrap_expr(self._pyexpr.map(f, return_dtype))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprapply"><a class="header" href="#polarslazyexprexprapply"><code>polars.lazy.expr.Expr.apply</code></a></h3>
<pre><code class="language-python">apply(f: Callable[[pl.Series], pl.Series], 
    return_dtype: OptionalTypeDataType,) -&gt; Expr:
</code></pre>
<p>Apply a custom UDF in a GroupBy context. This is syntactic sugar for the <code>apply</code> method which operates on all
groups at once. The UDF passed to this expression will operate on a single group.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>f</code>]: Lambda/ function to apply.</li>
<li>[<code>return_dtype</code>]: Dtype of the output Series.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-python">df = pl.DataFrame({&quot;a&quot;: [1,  2,  1,  1],
           &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;]})

(df
 .lazy()
 .groupby(&quot;b&quot;)
 .agg([col(&quot;a&quot;).apply(lambda x: x.sum())])
 .collect()
)
</code></pre>
<blockquote>
<p>returns</p>
</blockquote>
<pre><code class="language-text">shape: (3, 2)
╭─────┬─────╮
│ b   ┆ a   │
│ --- ┆ --- │
│ str ┆ i64 │
╞═════╪═════╡
│ a   ┆ 1   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ b   ┆ 2   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ c   ┆ 2   │
╰─────┴─────╯
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def apply(
        self,
        f: Callable[[&quot;pl.Series&quot;], &quot;pl.Series&quot;],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a custom UDF in a GroupBy context. This is syntactic sugar for the `apply` method which operates on all
        groups at once. The UDF passed to this expression will operate on a single group.

        Parameters
        ----------
        f
            Lambda/ function to apply.
        return_dtype
            Dtype of the output Series.

        # Example

        ```python
        df = pl.DataFrame({&quot;a&quot;: [1,  2,  1,  1],
                   &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;]})

        (df
         .lazy()
         .groupby(&quot;b&quot;)
         .agg([col(&quot;a&quot;).apply(lambda x: x.sum())])
         .collect()
        )
        ```

        &gt; returns

        ```text
        shape: (3, 2)
        ╭─────┬─────╮
        │ b   ┆ a   │
        │ --- ┆ --- │
        │ str ┆ i64 │
        ╞═════╪═════╡
        │ a   ┆ 1   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ b   ┆ 2   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ c   ┆ 2   │
        ╰─────┴─────╯
        ```
        &quot;&quot;&quot;

        # input x: Series of type list containing the group values
        def wrap_f(x: &quot;pl.Series&quot;) -&gt; &quot;pl.Series&quot;:
            return x.apply(f, return_dtype=return_dtype)

        return self.map(wrap_f)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprapplywrap_f"><a class="header" href="#polarslazyexprexprapplywrap_f"><code>polars.lazy.expr.Expr.apply.wrap_f</code></a></h3>
<pre><code class="language-python">wrap_f(x: pl.Series) -&gt; pl.Series:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">        def wrap_f(x: &quot;pl.Series&quot;) -&gt; &quot;pl.Series&quot;:
            return x.apply(f, return_dtype=return_dtype)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprexplode"><a class="header" href="#polarslazyexprexprexplode"><code>polars.lazy.expr.Expr.explode</code></a></h3>
<pre><code class="language-python">explode() -&gt; Expr:
</code></pre>
<p>Explode a list or utf8 Series. This means that every item is expanded to a new row.</p>
<p><strong>Returns:</strong></p>
<p>Exploded Series of same dtype</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def explode(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Explode a list or utf8 Series. This means that every item is expanded to a new row.

        Returns
        -------
        Exploded Series of same dtype
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.explode())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprtake_every"><a class="header" href="#polarslazyexprexprtake_every"><code>polars.lazy.expr.Expr.take_every</code></a></h3>
<pre><code class="language-python">take_every(n: int) -&gt; Expr:
</code></pre>
<p>Take every nth value in the Series and return as a new Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def take_every(self, n: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take every nth value in the Series and return as a new Series.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.take_every(n))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprhead"><a class="header" href="#polarslazyexprexprhead"><code>polars.lazy.expr.Expr.head</code></a></h3>
<pre><code class="language-python">head(n: Optionalint) -&gt; Expr:
</code></pre>
<p>Take the first n values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def head(self, n: Optional[int] = None) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take the first n values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.head(n))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprtail"><a class="header" href="#polarslazyexprexprtail"><code>polars.lazy.expr.Expr.tail</code></a></h3>
<pre><code class="language-python">tail(n: Optionalint) -&gt; Expr:
</code></pre>
<p>Take the last n values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def tail(self, n: Optional[int] = None) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take the last n values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.tail(n))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprpow"><a class="header" href="#polarslazyexprexprpow"><code>polars.lazy.expr.Expr.pow</code></a></h3>
<pre><code class="language-python">pow(exponent: float) -&gt; Expr:
</code></pre>
<p>Raise expression to the power of exponent.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def pow(self, exponent: float) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Raise expression to the power of exponent.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.pow(exponent))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexpris_in"><a class="header" href="#polarslazyexprexpris_in"><code>polars.lazy.expr.Expr.is_in</code></a></h3>
<pre><code class="language-python">is_in(other: Union[Expr, tp.List[Any]]) -&gt; Expr:
</code></pre>
<p>Check if elements of this Series are in the right Series, or List values of the right Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: Series of primitive type or List type.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Expr that evaluates to a Boolean Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_in(self, other: Union[&quot;Expr&quot;, tp.List[Any]]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Check if elements of this Series are in the right Series, or List values of the right Series.

        Parameters
        ----------
        other
            Series of primitive type or List type.

        Returns
        -------
        Expr that evaluates to a Boolean Series.
        &quot;&quot;&quot;
        if isinstance(other, list):
            other = lit(pl.Series(&quot;&quot;, other))
        return wrap_expr(self._pyexpr.is_in(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprrepeat_by"><a class="header" href="#polarslazyexprexprrepeat_by"><code>polars.lazy.expr.Expr.repeat_by</code></a></h3>
<pre><code class="language-python">repeat_by(by: Expr) -&gt; Expr:
</code></pre>
<p>Repeat the elements in this Series <code>n</code> times by dictated by the number given by <code>by</code>.
The elements are expanded into a <code>List</code></p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>by</code>]: Numeric column that determines how often the values will be repeated.
The column will be coerced to UInt32. Give this dtype to make the coercion a no-op.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Series of type List</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def repeat_by(self, by: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Repeat the elements in this Series `n` times by dictated by the number given by `by`.
        The elements are expanded into a `List`

        Parameters
        ----------
        by
            Numeric column that determines how often the values will be repeated.
            The column will be coerced to UInt32. Give this dtype to make the coercion a no-op.

        Returns
        -------
        Series of type List
        &quot;&quot;&quot;
        by = expr_to_lit_or_expr(by, False)
        return wrap_expr(self._pyexpr.repeat_by(by._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexpris_between"><a class="header" href="#polarslazyexprexpris_between"><code>polars.lazy.expr.Expr.is_between</code></a></h3>
<pre><code class="language-python">is_between(start: Union[Expr, datetime], 
    end: Union[Expr, datetime],) -&gt; Expr:
</code></pre>
<p>Check if this expression is between start and end.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_between(
        self, start: Union[&quot;Expr&quot;, datetime], end: Union[&quot;Expr&quot;, datetime]
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Check if this expression is between start and end.
        &quot;&quot;&quot;
        cast_to_date64 = False
        if isinstance(start, datetime):
            start = lit(start)
            cast_to_date64 = True
        if isinstance(end, datetime):
            end = lit(end)
            cast_to_date64 = True
        if cast_to_date64:
            expr = self.cast(Date64)
        else:
            expr = self
        return ((expr &gt; start) &amp; (expr &lt; end)).alias(&quot;is_between&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprdt"><a class="header" href="#polarslazyexprexprdt"><code>polars.lazy.expr.Expr.dt</code></a></h3>
<pre><code class="language-python">dt() -&gt; ExprDateTimeNameSpace:
</code></pre>
<p>Create an object namespace of all datetime related methods.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def dt(self) -&gt; &quot;ExprDateTimeNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all datetime related methods.
        &quot;&quot;&quot;
        return ExprDateTimeNameSpace(self)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprstr"><a class="header" href="#polarslazyexprexprstr"><code>polars.lazy.expr.Expr.str</code></a></h3>
<pre><code class="language-python">str() -&gt; ExprStringNameSpace:
</code></pre>
<p>Create an object namespace of all string related methods.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def str(self) -&gt; &quot;ExprStringNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all string related methods.
        &quot;&quot;&quot;
        return ExprStringNameSpace(self)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprhash"><a class="header" href="#polarslazyexprexprhash"><code>polars.lazy.expr.Expr.hash</code></a></h3>
<pre><code class="language-python">hash(k0: int, k1: int, k2: int, k3: int) -&gt; pl.Expr:
</code></pre>
<p>Hash the Series.</p>
<p>The hash value is of type <code>Date64</code></p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>k0</code>]: seed parameter</li>
<li>[<code>k1</code>]: seed parameter</li>
<li>[<code>k2</code>]: seed parameter</li>
<li>[<code>k3</code>]: seed parameter</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def hash(self, k0: int = 0, k1: int = 1, k2: int = 2, k3: int = 3) -&gt; &quot;pl.Expr&quot;:
        &quot;&quot;&quot;
        Hash the Series.

        The hash value is of type `Date64`

        Parameters
        ----------
        k0
            seed parameter
        k1
            seed parameter
        k2
            seed parameter
        k3
            seed parameter
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.hash(k0, k1, k2, k3))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarslazyexprexprreinterpret"><a class="header" href="#polarslazyexprexprreinterpret"><code>polars.lazy.expr.Expr.reinterpret</code></a></h3>
<pre><code class="language-python">reinterpret(signed: bool) -&gt; pl.Expr:
</code></pre>
<p>Reinterpret the underlying bits as a signed/unsigned integer.
This operation is only allowed for 64bit integers. For lower bits integers,
you can safely use that cast operation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>signed</code>]: True -&gt; pl.Int64
False -&gt; pl.UInt64</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def reinterpret(self, signed: bool) -&gt; &quot;pl.Expr&quot;:
        &quot;&quot;&quot;
        Reinterpret the underlying bits as a signed/unsigned integer.
        This operation is only allowed for 64bit integers. For lower bits integers,
        you can safely use that cast operation.

        Parameters
        ----------
        signed
            True -&gt; pl.Int64
            False -&gt; pl.UInt64
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.reinterpret(signed))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../../polars/lazy/expr.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../../polars/lazy/expr/ExprStringNameSpace.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../../polars/lazy/expr.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../../polars/lazy/expr/ExprStringNameSpace.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../../../theme/js/index.js"></script>
        

        

    </body>
</html>
